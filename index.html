<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>運氣訓練工具 V2-13-S3（修仙網頁線上版）</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --container-bg: #ffffff;
            --text-color: #333;
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --secondary-hover: #545b62;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --gold-color: #DAA520;
            --teal-color: #20c997;
            --purple-color: #6f42c1;
            --border-radius: 8px;
            --box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        #app-container {
            width: 100%;
            max-width: 700px;
            background-color: var(--container-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            box-sizing: border-box;
        }

        h1, h2, h3 {
            text-align: center;
            margin-top: 0;
        }

        button {
            display: block;
            width: 100%;
            padding: 12px;
            font-size: 16px;
            margin: 8px 0;
            border-radius: 6px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            background-color: var(--primary-color);
            color: white;
            -webkit-tap-highlight-color: transparent; /* 移除行動裝置點擊高亮 */
        }
        button:hover {
            background-color: var(--primary-hover);
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-warning { background-color: var(--warning-color); color: #333; }
        .btn-warning:hover { background-color: #e0a800; }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #b22a38; }
        .btn-secondary { background-color: var(--secondary-color); }
        .btn-secondary:hover { background-color: var(--secondary-hover); }


        .info-section {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: var(--border-radius);
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }
        
        .info-section p {
            margin: 6px 0;
        }

        progress {
            width: 100%;
            height: 18px;
            border-radius: 9px;
            overflow: hidden;
            border: none;
        }
        progress::-webkit-progress-bar {
            background-color: #e9ecef;
        }
        progress::-webkit-progress-value {
            background-color: var(--success-color);
            transition: width 0.5s ease-in-out;
        }
        progress::-moz-progress-bar {
            background-color: var(--success-color);
        }

        .game-grid {
            display: grid;
            gap: 10px;
            margin: 20px 0;
        }

        .grid-btn {
            width: 100%;
            height: 60px;
            font-size: 24px;
            padding: 0;
            background-color: #f8f9fa;
            color: var(--text-color);
            border: 1px solid #ccc;
        }
        .grid-btn:hover {
            background-color: #e2e6ea;
        }
        .grid-btn.selected {
            border-color: var(--primary-color);
            background-color: #e0f7fa;
            box-shadow: 0 0 5px var(--primary-color);
        }
        .grid-btn.hint-correct {
            border: 2px solid var(--gold-color);
            background-color: #fff7d6;
        }
        .grid-btn.hint-wrong {
            border: 2px solid var(--danger-color);
            background-color: #ffe6e6;
        }
        .grid-btn.checked {
            background-color: #d1ecf1;
            border-color: var(--info-color);
        }


        .feedback {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .feedback.success { color: var(--success-color); }
        .feedback.error { color: var(--danger-color); }
        .feedback.info { color: var(--info-color); }
        
        .message {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .msg-daily { color: #004085; background-color: #cce5ff; border: 1px solid #b8daff; }
        .msg-shop { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb; }
        .msg-shop-fail { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; }
        .msg-levelup { color: var(--purple-color); font-weight: bold; }
        .msg-reward { color: var(--gold-color); font-weight: bold; }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fff;
            margin: auto;
            padding: 20px;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .modal-header h2 { margin: 0; font-size: 1.5em; }
        .modal-body {
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-item-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .modal-item-row label { flex-grow: 1; }
        .modal-item-row input[type="number"] {
            width: 70px;
            padding: 5px;
            text-align: right;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .modal-footer {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
        .close-btn:hover { color: #000; }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="app"></div>
    </div>

    <!-- Modal Template -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title"></h2>
                <button class="close-btn" id="modal-close-btn">&times;</button>
            </div>
            <div id="modal-body" class="modal-body"></div>
            <div id="modal-footer" class="modal-footer"></div>
        </div>
    </div>

<script>
// =================================================================================
// 運氣訓練工具 V9-0 - JavaScript 離線網頁版
// 作者：Gemini (移植自使用者提供的 Python 腳本)
// 版本：1.2 - 修正訓練模式中答案位置規律排列的問題，實現真正隨機。
// =================================================================================

document.addEventListener('DOMContentLoaded', () => {

// ===================== 遊戲核心設定與數據 (來自 Python) =====================
const SCORE_FILE = "max_scores"; // localStorage key
const STATS_FILE = "training_stats"; // localStorage key
// # 秘境試煉最高分資料儲存鍵，用於記錄玩家在各難度秘境試煉中的最佳成績。
const TRIAL_SCORE_FILE = "max_trial_scores";

// # 秘境試煉最高紀錄載入後存放於此物件，格式類似於 maxScores: { difficulty: bestScore }
let maxTrialScores = {};

const DIFFICULTY_WIN_RATE = {1:90, 2:80, 3:65, 4:50, 5:35, 6:25, 7:15, 8:10, 9:7, 10:5};
const REDEEM_1_COST = 50;
const REDEEM_10_COST = 500;
const REDEEM_100_COST = 5000;
const REDEEM_1000_COST = 50000;
const STONE_EXCHANGE_COST = 100;
const STONE_100_EXCHANGE_COST = 10000;
const STONE_1000_EXCHANGE_COST = 100000;

const TRAINING_MILESTONES = {
    5: {"rewards": 1, "title": "1.宗門的基石"}, 10: {"rewards": 1, "title": "2.見習弟子"}, 25: {"rewards": 2, "title": "3.外門雜役"}, 50: {"rewards": 2, "title": "4.外門弟子"}, 75: {"rewards": 3, "title": "5.外門師兄"}, 100: {"rewards": 5, "title": "6.外門菁英"}, 150: {"rewards": 3, "title": "7.內門候補"}, 200: {"rewards": 4, "title": "8.內門弟子"}, 300: {"rewards": 5, "title": "9.內門師兄"}, 400: {"rewards": 5, "title": "10.內門菁英"}, 500: {"rewards": 10, "title": "11.宗門執事"}, 600: {"rewards": 5, "title": "12.任務堂弟子"}, 700: {"rewards": 5, "title": "13.傳法堂弟子"}, 800: {"rewards": 5, "title": "14.煉丹閣弟子"}, 900: {"rewards": 5, "title": "15.煉器坊弟子"}, 1000: {"rewards": 15, "title": "16.親傳弟子"}, 1200: {"rewards": 6, "title": "17.戒律堂執事"}, 1400: {"rewards": 6, "title": "18.藏經閣執事"}, 1600: {"rewards": 6, "title": "19.百草園管事"}, 1800: {"rewards": 6, "title": "20.萬獸山管事"}, 2000: {"rewards": 20, "title": "21.首席大弟子"}, 2500: {"rewards": 10, "title": "22.任務堂長老"}, 3000: {"rewards": 10, "title": "23.傳法堂長老"}, 3500: {"rewards": 10, "title": "24.煉丹閣長老"}, 4000: {"rewards": 10, "title": "25.煉器坊長老"}, 5000: {"rewards": 25, "title": "26.宗門長老"}, 6000: {"rewards": 12, "title": "27.刑法長老"}, 7000: {"rewards": 12, "title": "28.傳功長老"}, 8000: {"rewards": 12, "title": "29.客卿長老"}, 9000: {"rewards": 12, "title": "30.巡山長老"}, 10000: {"rewards": 30, "title": "31.宗門護法"}, 12500: {"rewards": 15, "title": "32.丹道峰主"}, 15000: {"rewards": 15, "title": "33.器道峰主"}, 17500: {"rewards": 15, "title": "34.劍道峰主"}, 20000: {"rewards": 40, "title": "35.太上長老"}, 25000: {"rewards": 20, "title": "36.宗門聖子"}, 30000: {"rewards": 20, "title": "37.宗門聖女"}, 35000: {"rewards": 20, "title": "38.行走的傳說"}, 40000: {"rewards": 20, "title": "39.護道人"}, 50000: {"rewards": 50, "title": "40.代宗主"}, 60000: {"rewards": 25, "title": "41.鎮派老祖"}, 70000: {"rewards": 25, "title": "42.開派祖師"}, 80000: {"rewards": 25, "title": "43.渡劫真仙"}, 90000: {"rewards": 25, "title": "44.飛升之人"}, 100000: {"rewards": 100, "title": "45.人間之神"}, 120000: {"rewards": 50, "title": "46.天界行者"}, 140000: {"rewards": 50, "title": "47.星界遊神"}, 160000: {"rewards": 50, "title": "48.位面之主"}, 180000: {"rewards": 50, "title": "49.時空旅者"}, 200000: {"rewards": 100, "title": "50.萬古傳說"}, 250000: {"rewards": 100, "title": "51.因果之手"}, 300000: {"rewards": 100, "title": "52.命運編織者"}, 400000: {"rewards": 100, "title": "53規則制定者"}, 500000: {"rewards": 100, "title": "54.大道之源"}, 1000000: {"rewards": 500, "title": "55.終極造物主"},
};

const CULTIVATION_STAGES = (() => {
    let stages = [[0, 0, "凡人初入道"]];
    const LEVELS_PER_STAGE = 10;
    const score_cycle = Object.values(DIFFICULTY_WIN_RATE);
    let base_need_exp = 0;
    let need_step = 10;
    const stage_names = ["1.凡人", "2.練氣", "3.築基", "4.結丹", "5.元嬰", "6.化神", "7.煉虛", "8.合體", "9.大乘", "10.渡劫", "11.真仙", "12.金仙", "13.太乙金仙", "14.大羅金仙", "15.混元大羅", "16.仙王", "17.仙帝", "18.天尊", "19.祖仙", "20.無上", "21.超脫輪迴", "22.無上極境", "23.混沌無極", "24.大道歸一", "25.宇宙之主", "26.創世真神", "27.界外天尊", "28.混元道尊", "29.始源帝尊", "30.太初聖皇", "31.永恆之神", "32.混沌主宰", "33.萬道歸宗", "34.終極造物主", "35.無限永存者", "36.超維觀察者", "37.超越者", "38.真理化身", "39.虛無之神", "40.界上界主", "41.唯一真神","42.太上道祖","43.永劫不朽","44.無極本源","45.多元彼岸主","46.原初意志", "47.萬界始祖","48.終焉創世者","49.絕對真理","50.超越唯一","51.永恆王座"];
    stage_names.forEach(stage => {
        for (let sub = 1; sub <= LEVELS_PER_STAGE; sub++) {
            base_need_exp += need_step;
            const need_score = score_cycle[stages.length % score_cycle.length];
            stages.push([base_need_exp, need_score, `${stage}${sub}層`]);
        }
        need_step = Math.max(need_step + 1, Math.floor(need_step * 1.5));
    });
    return stages;
})();

const GRADE_NAMES = ["入品", "下品", "中品", "上品", "極品", "超品", "絕品", "寶品", "地品", "天品"];
const ITEM_TYPE_ORDER = ['兵器', '功法', '陣法', '仙丹', '靈器', '靈符'];

const WEAPONS = {
    "入品青竹劍": {"type": "multi_choice", "n": 1, "exp_cost": 100, "upgrade_cost": 2000, "desc": "增加1次作答次數"}, "入品銅背刀": {"type": "multi_choice", "n": 1, "exp_cost": 100, "upgrade_cost": 2000, "desc": "增加1次作答次數"}, "入品碎雲槍": {"type": "multi_choice", "n": 1, "exp_cost": 100, "upgrade_cost": 2000, "desc": "增加1次作答次數"},
    "下品寒鋒劍": {"type": "multi_choice", "n": 2, "exp_cost": 200, "upgrade_cost": 4000, "desc": "增加2次作答次數"}, "下品裂石刀": {"type": "multi_choice", "n": 2, "exp_cost": 200, "upgrade_cost": 4000, "desc": "增加2次作答次數"}, "下品游龍槍": {"type": "multi_choice", "n": 2, "exp_cost": 200, "upgrade_cost": 4000, "desc": "增加2次作答次數"},
    "中品青霜劍": {"type": "multi_choice", "n": 3, "exp_cost": 400, "upgrade_cost": 8000, "desc": "增加3次作答次數"}, "中品赤焰刀": {"type": "multi_choice", "n": 3, "exp_cost": 400, "upgrade_cost": 8000, "desc": "增加3次作答次數"}, "中品霆罡槍": {"type": "multi_choice", "n": 3, "exp_cost": 400, "upgrade_cost": 8000, "desc": "增加3次作答次數"},
    "上品流光劍": {"type": "multi_choice", "n": 4, "exp_cost": 800, "upgrade_cost": 16000, "desc": "增加4次作答次數"}, "上品蒼鯨刀": {"type": "multi_choice", "n": 4, "exp_cost": 800, "upgrade_cost": 16000, "desc": "增加4次作答次數"}, "上品破軍槍": {"type": "multi_choice", "n": 4, "exp_cost": 800, "upgrade_cost": 16000, "desc": "增加4次作答次數"},
    "極品離火飛劍": {"type": "multi_choice", "n": 5, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "增加5次作答次數"}, "極品玄冥鬼刀": {"type": "multi_choice", "n": 5, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "增加5次作答次數"}, "極品紫電神槍": {"type": "multi_choice", "n": 5, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "增加5次作答次數"},
    "超品太虛劍胚": {"type": "multi_choice", "n": 6, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "增加6次作答次數"}, "超品無相刀胎": {"type": "multi_choice", "n": 6, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "增加6次作答次數"}, "超品天罡槍魂": {"type": "multi_choice", "n": 6, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "增加6次作答次數"},
    "絕品太白星劍": {"type": "multi_choice", "n": 7, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "增加7次作答次數"}, "絕品玄武鎮海刀": {"type": "multi_choice", "n": 7, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "增加7次作答次數"}, "絕品青龍驚雷槍": {"type": "multi_choice", "n": 7, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "增加7次作答次數"},
    "寶品懸天飛仙劍": {"type": "multi_choice", "n": 8, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "增加8次作答次數"}, "寶品戮神血月刀": {"type": "multi_choice", "n": 8, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "增加8次作答次數"}, "寶品破界鎏金槍": {"type": "multi_choice", "n": 8, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "增加8次作答次數"},
    "地品崑崙斬邪劍": {"type": "multi_choice", "n": 9, "exp_cost": 25600, "upgrade_cost": 512000, "desc": "增加9次作答次數"}, "地品厚土鎮岳刀": {"type": "multi_choice", "n": 9, "exp_cost": 25600, "upgrade_cost": 512000, "desc": "增加9次作答次數"}, "地品後土誓盟槍": {"type": "multi_choice", "n": 9, "exp_cost": 25600, "upgrade_cost": 512000, "desc": "增加9次作答次數"},
    "天品太清誅仙劍": {"type": "multi_choice", "n": 10, "exp_cost": 51200, "upgrade_cost": 0, "desc": "增加10次作答次數"}, "天品天道審刑刀": {"type": "multi_choice", "n": 10, "exp_cost": 51200, "upgrade_cost": 0, "desc": "增加10次作答次數"}, "天品乾坤定海槍": {"type": "multi_choice", "n": 10, "exp_cost": 51200, "upgrade_cost": 0, "desc": "增加10次作答次數"},
};
const TECHNIQUES = {
    "入品築基吐納訣": {"type": "reveal_wrong", "n": 1, "exp_cost": 0, "upgrade_cost": 1000, "desc": "顯現1個錯誤答案"}, "入品松鹤長青功": {"type": "reveal_wrong", "n": 1, "exp_cost": 0, "upgrade_cost": 1000, "desc": "顯現1個錯誤答案"},
    "下品小周天行氣": {"type": "reveal_wrong", "n": 2, "exp_cost": 100, "upgrade_cost": 2000, "desc": "顯現2個錯誤答案"}, "下品青木養元術": {"type": "reveal_wrong", "n": 2, "exp_cost": 100, "upgrade_cost": 2000, "desc": "顯現2個錯誤答案"},
    "中品玄息歸一訣": {"type": "reveal_wrong", "n": 3, "exp_cost": 200, "upgrade_cost": 4000, "desc": "顯現3個錯誤答案"}, "中品赤陽煉體篇": {"type": "reveal_wrong", "n": 3, "exp_cost": 200, "upgrade_cost": 4000, "desc": "顯現3個錯誤答案"},
    "上品三花聚頂訣": {"type": "reveal_wrong", "n": 4, "exp_cost": 400, "upgrade_cost": 8000, "desc": "顯現4個錯誤答案"}, "上品紫府還真經": {"type": "reveal_wrong", "n": 4, "exp_cost": 400, "upgrade_cost": 8000, "desc": "顯現4個錯誤答案"},
    "極品太陰煉月經": {"type": "reveal_wrong", "n": 5, "exp_cost": 800, "upgrade_cost": 16000, "desc": "顯現5個錯誤答案"}, "極品離火冥雷經": {"type": "reveal_wrong", "n": 5, "exp_cost": 800, "upgrade_cost": 16000, "desc": "顯現5個錯誤答案"},
    "超品太乙歸元經": {"type": "reveal_wrong", "n": 6, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "顯現6個錯誤答案"}, "超品無相玄功": {"type": "reveal_wrong", "n": 6, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "顯現6個錯誤答案"},
    "絕品九轉金身訣": {"type": "reveal_wrong", "n": 7, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "顯現7個錯誤答案"}, "絕品五雷正法": {"type": "reveal_wrong", "n": 7, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "顯現7個錯誤答案"},
    "寶品洞天造化經": {"type": "reveal_wrong", "n": 8, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "顯現8個錯誤答案"}, "寶品先天一炁訣": {"type": "reveal_wrong", "n": 8, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "顯現8個錯誤答案"},
    "地品地藏冥心經": {"type": "reveal_wrong", "n": 9, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "顯現9個錯誤答案"}, "地品厚土無疆訣": {"type": "reveal_wrong", "n": 9, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "顯現9個錯誤答案"},
    "天品大道混元藏": {"type": "reveal_wrong", "n": 10, "exp_cost": 25600, "upgrade_cost": 0, "desc": "顯現10個錯誤答案"}, "天品無極本源經": {"type": "reveal_wrong", "n": 10, "exp_cost": 25600, "upgrade_cost": 0, "desc": "顯現10個錯誤答案"},
};
const FORMATIONS = {
    "入品三才聚靈陣": {"type": "add_time", "n": 1, "exp_cost": 10, "upgrade_cost": 200, "desc": "增加1秒作答時間"}, "入品四門陷敵陣": {"type": "add_time", "n": 1, "exp_cost": 10, "upgrade_cost": 200, "desc": "增加1秒作答時間"},
    "下品五行護山陣": {"type": "add_time", "n": 2, "exp_cost": 20, "upgrade_cost": 400, "desc": "增加2秒作答時間"}, "下品六甲迷踪陣": {"type": "add_time", "n": 2, "exp_cost": 20, "upgrade_cost": 400, "desc": "增加2秒作答時間"},
    "中品七曜星門陣": {"type": "add_time", "n": 3, "exp_cost": 40, "upgrade_cost": 800, "desc": "增加3秒作答時間"}, "中品八門金鎖陣": {"type": "add_time", "n": 3, "exp_cost": 40, "upgrade_cost": 800, "desc": "增加3秒作答時間"},
    "上品九宮幻天陣": {"type": "add_time", "n": 4, "exp_cost": 80, "upgrade_cost": 1600, "desc": "增加4秒作答時間"}, "上品十二天罡陣": {"type": "add_time", "n": 4, "exp_cost": 80, "upgrade_cost": 1600, "desc": "增加4秒作答時間"},
    "極品玄武鎮海陣": {"type": "add_time", "n": 5, "exp_cost": 160, "upgrade_cost": 3200, "desc": "增加5秒作答時間"}, "極品白虎裂天陣": {"type": "add_time", "n": 5, "exp_cost": 160, "upgrade_cost": 3200, "desc": "增加5秒作答時間"},
    "超品青龍騰雲陣": {"type": "add_time", "n": 6, "exp_cost": 320, "upgrade_cost": 6400, "desc": "增加6秒作答時間"}, "超品朱雀焚天陣": {"type": "add_time", "n": 6, "exp_cost": 320, "upgrade_cost": 6400, "desc": "增加6秒作答時間"},
    "絕品四象合一鎮域陣": {"type": "add_time", "n": 7, "exp_cost": 640, "upgrade_cost": 12800, "desc": "增加7秒作答時間"}, "絕品太乙混元封天陣": {"type": "add_time", "n": 7, "exp_cost": 640, "upgrade_cost": 12800, "desc": "增加7秒作答時間"},
    "寶品萬靈歸源陣": {"type": "add_time", "n": 8, "exp_cost": 1280, "upgrade_cost": 25600, "desc": "增加8秒作答時間"}, "寶品先天兩儀反演陣": {"type": "add_time", "n": 8, "exp_cost": 1280, "upgrade_cost": 25600, "desc": "增加8秒作答時間"},
    "地品九地鎮魔大陣": {"type": "add_time", "n": 9, "exp_cost": 2560, "upgrade_cost": 51200, "desc": "增加9秒作答時間"}, "地品厚土歸墟陣": {"type": "add_time", "n": 9, "exp_cost": 2560, "upgrade_cost": 51200, "desc": "增加9秒作答時間"},
    "天品先天一炁化劫大陣": {"type": "add_time", "n": 10, "exp_cost": 5120, "upgrade_cost": 0, "desc": "增加10秒作答時間"}, "天品無極乾坤界域陣": {"type": "add_time", "n": 10, "exp_cost": 5120, "upgrade_cost": 0, "desc": "增加10秒作答時間"},
};

const UPGRADE_PATHS = {
    "入品青竹劍": "下品寒鋒劍", "下品寒鋒劍": "中品青霜劍", "中品青霜劍": "上品流光劍", "上品流光劍": "極品離火飛劍", "極品離火飛劍": "超品太虛劍胚", "超品太虛劍胚": "絕品太白星劍", "絕品太白星劍": "寶品懸天飛仙劍", "寶品懸天飛仙劍": "地品崑崙斬邪劍", "地品崑崙斬邪劍": "天品太清誅仙劍",
    "入品銅背刀": "下品裂石刀", "下品裂石刀": "中品赤焰刀", "中品赤焰刀": "上品蒼鯨刀", "上品蒼鯨刀": "極品玄冥鬼刀", "極品玄冥鬼刀": "超品無相刀胎", "超品無相刀胎": "絕品玄武鎮海刀", "絕品玄武鎮海刀": "寶品戮神血月刀", "寶品戮神血月刀": "地品厚土鎮岳刀", "地品厚土鎮岳刀": "天品天道審刑刀",
    "入品碎雲槍": "下品游龍槍", "下品游龍槍": "中品霆罡槍", "中品霆罡槍": "上品破軍槍", "上品破軍槍": "極品紫電神槍", "極品紫電神槍": "超品天罡槍魂", "超品天罡槍魂": "絕品青龍驚雷槍", "絕品青龍驚雷槍": "寶品破界鎏金槍", "寶品破界鎏金槍": "地品後土誓盟槍", "地品後土誓盟槍": "天品乾坤定海槍",
    "入品築基吐納訣": "下品小周天行氣", "下品小周天行氣": "中品玄息歸一訣", "中品玄息歸一訣": "上品三花聚頂訣", "上品三花聚頂訣": "極品太陰煉月經", "極品太陰煉月經": "超品太乙歸元經", "超品太乙歸元經": "絕品九轉金身訣", "絕品九轉金身訣": "寶品洞天造化經", "寶品洞天造化經": "地品地藏冥心經", "地品地藏冥心經": "天品大道混元藏",
    "入品松鹤長青功": "下品青木養元術", "下品青木養元術": "中品赤陽煉體篇", "中品赤陽煉體篇": "上品紫府還真經", "上品紫府還真經": "極品離火冥雷經", "極品離火冥雷經": "超品無相玄功", "超品無相玄功": "絕品五雷正法", "絕品五雷正法": "寶品先天一炁訣", "寶品先天一炁訣": "地品厚土無疆訣", "地品厚土無疆訣": "天品無極本源經",
    "入品三才聚靈陣": "下品五行護山陣", "下品五行護山陣": "中品七曜星門陣", "中品七曜星門陣": "上品九宮幻天陣", "上品九宮幻天陣": "極品玄武鎮海陣", "極品玄武鎮海陣": "超品青龍騰雲陣", "超品青龍騰雲陣": "絕品四象合一鎮域陣", "絕品四象合一鎮域陣": "寶品萬靈歸源陣", "寶品萬靈歸源陣": "地品九地鎮魔大陣", "地品九地鎮魔大陣": "天品先天一炁化劫大陣",
    "入品四門陷敵陣": "下品六甲迷踪陣", "下品六甲迷踪陣": "中品八門金鎖陣", "中品八門金鎖陣": "上品十二天罡陣", "上品十二天罡陣": "極品白虎裂天陣", "極品白虎裂天陣": "超品朱雀焚天陣", "超品朱雀焚天陣": "絕品太乙混元封天陣", "絕品太乙混元封天陣": "寶品先天兩儀反演陣", "寶品先天兩儀反演陣": "地品厚土歸墟陣", "地品厚土歸墟陣": "天品無極乾坤界域陣",
};

const ITEM_EFFECTS = {
    "入品仙丹": {"type": "exp", "n": 10, "desc": "增加 10 修煉經驗"}, "下品仙丹": {"type": "exp", "n": 30, "desc": "增加 30 修煉經驗"}, "中品仙丹": {"type": "exp", "n": 70, "desc": "增加 70 修煉經驗"}, "上品仙丹": {"type": "exp", "n": 150, "desc": "增加 150 修煉經驗"}, "極品仙丹": {"type": "exp", "n": 310, "desc": "增加 310 修煉經驗"}, "超品仙丹": {"type": "exp", "n": 630, "desc": "增加 630 修煉經驗"}, "絕品仙丹": {"type": "exp", "n": 1270, "desc": "增加 1270 修煉經驗"}, "寶品仙丹": {"type": "exp", "n": 2550, "desc": "增加 2550 修煉經驗"}, "地品仙丹": {"type": "exp", "n": 5110, "desc": "增加 5110 修煉經驗"}, "天品仙丹": {"type": "exp", "n": 10230, "desc": "增加 10230 修煉經驗"},
    "入品靈符": {"type": "wrong", "n": 1, "desc": "排除 1 個錯誤答案"}, "下品靈符": {"type": "wrong", "n": 2, "desc": "排除 2 個錯誤答案"}, "中品靈符": {"type": "wrong", "n": 3, "desc": "排除 3 個錯誤答案"}, "上品靈符": {"type": "wrong", "n": 4, "desc": "排除 4 個錯誤答案"}, "極品靈符": {"type": "wrong", "n": 5, "desc": "排除 5 個錯誤答案"}, "超品靈符": {"type": "wrong", "n": 6, "desc": "排除 6 個錯誤答案"}, "絕品靈符": {"type": "wrong", "n": 7, "desc": "排除 7 個錯誤答案"}, "寶品靈符": {"type": "wrong", "n": 8, "desc": "排除 8 個錯誤答案"}, "地品靈符": {"type": "wrong", "n": 9, "desc": "排除 9 個錯誤答案"}, "天品靈符": {"type": "wrong", "n": 10, "desc": "排除 10 個錯誤答案"},
    "入品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "下品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "中品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "上品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "極品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "超品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "絕品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "寶品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "地品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "天品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"},
    ...WEAPONS, ...TECHNIQUES, ...FORMATIONS
};

const ITEM_STONE_PRICES = {
    "入品仙丹": 3, "下品仙丹": 6, "中品仙丹": 12, "上品仙丹": 24, "極品仙丹": 48, "超品仙丹": 96, "絕品仙丹": 192, "寶品仙丹": 384, "地品仙丹": 768, "天品仙丹": 1536,
    "入品靈符": 1, "下品靈符": 2, "中品靈符": 4, "上品靈符": 8, "極品靈符": 16, "超品靈符": 32, "絕品靈符": 64, "寶品靈符": 128, "地品靈符": 256, "天品靈符": 512,
    "入品靈器": 5, "下品靈器": 10, "中品靈器": 20, "上品靈器": 40, "極品靈器": 80, "超品靈器": 160, "絕品靈器": 320, "寶品靈器": 640, "地品靈器": 1280, "天品靈器": 2560,
};

const ITEM_RENAME_MAP = {
    "普通仙丹": "入品仙丹", "普通靈符": "入品靈符", "普通靈器": "入品靈器",
};

const EMOJIS = ["😀","😂","😎","😡","😭","😍","😱","😴","😇","🤖"];
const ANIMALS = ["🐶","🐱","🐭","🐹","🐰","🦊","🐻","🐼","🐨","🐯","🦁","🐮","🐷","🐸","🐵","🦄","🐔","🐧","🐦","🐤"];
const FOODS = ["🍎","🍊","🍌","🍉","🍇","🍓","🥑","🍍","🥝","🍒","🍔","🍟","🍕","🌭","🥪","🥗","🍣","🍱","🥟","🍜"];
const COLORS = ["🔴","🟠","🟡","🟢","🔵","🟣","⚫","⚪","🟤","🟥","🟧","🟨","🟩","🟦","🟪","⬛","⬜","🟫","🔶","🔷"];
const SHAPES = ["🔺","🔵","⬛","⭐","🟩","🟧","🟥","⬜","🔶","🔷","🔳","🔲","🟫","🔸","🔹","⬟","⬢","⬣","⏺","⏹"];
const PLACES = ["🏠","🏢","🏬","🏭","🏰","🏯","🏝️","🏖️","⛩️","🎡","🎢","🎠","🗽","🗼","⛲","🕌","⛪","🛕","🏕️"];
const FLAGS = ["🇹🇼","🇯🇵","🇰🇷","🇨🇳","🇺🇸","🇬🇧","🇫🇷","🇩🇪","🇮🇹","🇪🇸","🇧🇷","🇨🇦","🇦🇺","🇳🇿","🇷🇺","🇸🇪","🇳🇴","🇮🇳","🇲🇽","🇿🇦"];
const NATURE = ["🌞","🌝","🌧️","⛈️","🌪️","🌈","🌊","🌋","❄️","🍃"];
const CARDS = ["🂱","🂲","🂳","🂴","🂵","🂶","🂷","🂸","🂹","🂺","🂻","🂼","🂽","🂾","🂡","🂢","🂣","🂤","🂥","🂦","🂧","🂨","🂩","🂪","🂫","🂬","🂭","🂮","🃁","🃂","🃃","🃄","🃅","🃆","🃇","🃈","🃉","🃊","🃋","🃌","🃍","🃎","🃑","🃒","🃓","🃔","🃕","🃖","🃗","🃘","🃙","🃚","🃛","🃜","🃝","🃞","🂠","🃏","🃟"];
const MAHJONG = ["🀇","🀈","🀉","🀊","🀋","🀌","🀍","🀎","🀏","🀙","🀚","🀛","🀜","🀝","🀞","🀟","🀠","🀡","🀐","🀑","🀒","🀓","🀔","🀕","🀖","🀗","🀘","🀀","🀁","🀂","🀃","🀄","🀅","🀆"];
const VEHICLES = ["🚗","🚕","🚙","🚌","🚎","🏎️","🚓","🚑","🚒","🚐","🚚","🚛","🚜","🛻","🛺","🚲","🛵","🏍️","🚔","🚍","✈️","🛫","🛬","🛩️","🚁","🛶","🚤","⛵","🛳️","🚀"];
const ZODIACS = ["♈","♉","♊","♋","♌","♍","♎","♏","♐","♑","♒","♓"];
const CLOCKS = ["🕛","🕐","🕑","🕒","🕓","🕔","🕕","🕖","🕗","🕘","🕙","🕚"];
const PROFESSIONS = ["🧑‍⚕️","🧑‍🏫","🧑‍🍳","🧑‍💻","🧑‍🔬","🧑‍🎨","🧑‍🚒","🧑‍✈️","🧑‍🚀","🧑‍🔧","🧑‍🌾","🧑‍🏭","🧑‍⚖️","🧑‍🎤","🧑‍🎓","👮‍♂️","👷‍♂️"];
const SPORTS = ["🎖️","🏆","🏅","🥇","🥈","🥉","⚽","⚾","🥎","🏀","🏐","🏈","🏉","🎾","🥏","🎳","🏏","🏑","🏒","🥍","🏓","🏸","🥊","🥋","🥅","⛳","⛸️","🎣","🤿","🎽","🎿","🛷","🥌","🎯"];
const OFFICE = ["📔","📕","📖","📗","📘","📙","📚","📓","📒","📃","📜","📄","📰","🗞️","📑","🔖","🏷️","✉️","📧","📨","📩","📤","📥","📦","📫","📪","📬","📭","📮","🗳️","✏️","✒️","🖋️","🖊️","🖌️","🖍️","📝","💼","📁","📂","🗂️","📅","📆","🗒️","🗓️","📇","📈","📉","📊","📋","📌","📍","📎","🖇️","📏","📐","✂️","🗃️","🗄️","🗑️","🪪"];
const TOOLS = ["🧳","🌡️","🧸","🧶","🪢","🔍","🔎","🕯️","💡","🔦","🔒","🔓","🔏","🔐","🔑","🗝️","🔨","🪓","⛏️","⚒️","🛠️","🗡️","⚔️","💣","🪃","🏹","🛡️","🪚","🔧","🪛","🔩","⚙️","🗜️","⚖️","🔗","⛓️","💥","🪝","🧰","🧲","🪜","🪏","⚗️","🧪","🧫","🔬","🔭","📡","💉","🩹","🩼","🩺","🩻","🚪","🪞","🪟","🛏️","🛋️","🪑","🚽","🪠","🚿","🛁","🪤","🪒","🧴","🧷","🧹","🧺","🧻","🪣","🧼","🫧","🪥","🧽","🧯","🛒","🚬","⚰️","🪦","⚱️","🪧"];
// 自動拆分辦公文具與工具/家居用品為前半(A)與後半(B)
const OFFICE_A = OFFICE.slice(0, Math.ceil(OFFICE.length / 2));
const OFFICE_B = OFFICE.slice(Math.ceil(OFFICE.length / 2));
const TOOLS_A = TOOLS.slice(0, Math.ceil(TOOLS.length / 2));
const TOOLS_B = TOOLS.slice(Math.ceil(TOOLS.length / 2));

// # === 新增符號與字母訓練題庫 ===
// 羅馬數字（大寫 1–12）
const ROMAN_NUMERALS_U = ["Ⅰ","Ⅱ","Ⅲ","Ⅳ","Ⅴ","Ⅵ","Ⅶ","Ⅷ","Ⅸ","Ⅹ","Ⅺ","Ⅻ"];
// 羅馬數字（小寫 1–12）
const ROMAN_NUMERALS_L = ["ⅰ","ⅱ","ⅲ","ⅳ","ⅴ","ⅵ","ⅶ","ⅷ","ⅸ","ⅹ","ⅺ","ⅻ"];
// 數學符號
const MATH_SYMBOLS = ["+","−","×","÷","±","=","≠","≈","≒","∽","≦","≧","≤","≥","∵","∴","＋","－","﹢","﹣","＜","＞","﹤","﹥","≮","≯","^","√","∞","∝"];
// # 羅馬數字（大寫 1-12）
const ROMAN_U = ["Ⅰ","Ⅱ","Ⅲ","Ⅳ","Ⅴ","Ⅵ","Ⅶ","Ⅷ","Ⅸ","Ⅹ","Ⅺ","Ⅻ"];
// # 羅馬數字（小寫 1-12）
const ROMAN_L = ["ⅰ","ⅱ","ⅲ","ⅳ","ⅴ","ⅵ","ⅶ","ⅷ","ⅸ","ⅹ","ⅺ","ⅻ"];
// 單位符號
const UNIT_SYMBOLS = ["℃","℉","㎙","㎚","㎛","㎜","㎝","㎞","㎟","㎠","㎡","㎢","㎣","㎤","㎥","㎦","㏎","㏕","㎍","㎎","㎏","㏄"];
// 月份符號（使用 CJK 圈字月份 1–12）
const MONTH_SYMBOLS = ["㋀","㋁","㋂","㋃","㋄","㋅","㋆","㋇","㋈","㋉","㋊","㋋"];
// 日期符號（1～31 與 0）
const DATE_SYMBOLS = ["㏠","㏡","㏢","㏣","㏤","㏥","㏦","㏧","㏨","㏩","㏪","㏫","㏬","㏭","㏮","㏯","㏰","㏱","㏲","㏳","㏴","㏵","㏶","㏷","㏸","㏹","㏺","㏻","㏼","㏽","㏾"];
// 有襯線粗體英文字母（大寫 A–Z）
const BOLD_SERIF_U = ["𝐀","𝐁","𝐂","𝐃","𝐄","𝐅","𝐆","𝐇","𝐈","𝐉","𝐊","𝐋","𝐌","𝐍","𝐎","𝐏","𝐐","𝐑","𝐒","𝐓","𝐔","𝐕","𝐖","𝐗","𝐘","𝐙"];
// 有襯線粗體英文字母（小寫 a–z）
const BOLD_SERIF_L = ["𝐚","𝐛","𝐜","𝐝","𝐞","𝐟","𝐠","𝐡","𝐢","𝐣","𝐤","𝐥","𝐦","𝐧","𝐨","𝐩","𝐪","𝐫","𝐬","𝐭","𝐮","𝐯","𝐰","𝐱","𝐲","𝐳"];
// 草書英文字母（大寫）
const SCRIPT_U = ["𝒜","𝐵","𝒞","𝒟","𝐸","𝐹","𝒢","𝐻","𝐼","𝒥","𝒦","𝐿","𝑀","𝒩","𝒪","𝒫","𝒬","𝑅","𝒮","𝒯","𝒰","𝒱","𝒲","𝒳","𝒴","𝒵"];
// 草書英文字母（小寫）
const SCRIPT_L = ["𝒶","𝒷","𝒸","𝒹","𝑒","𝒻","𝑔","𝒽","𝒾","𝒿","𝓀","𝓁","𝓂","𝓃","𝑜","𝓅","𝓆","𝓇","𝓈","𝓉","𝓊","𝓋","𝓌","𝓍","𝓎","𝓏"];
// 希臘字母（大寫）
const GREEK_U = ["Α","Β","Γ","Δ","Ε","Ζ","Η","Θ","Ι","Κ","Λ","Μ","Ν","Ξ","Ο","Π","Ρ","Σ","Τ","Υ","Φ","Χ","Ψ","Ω"];
// 希臘字母（小寫）
const GREEK_L = ["α","β","γ","δ","ε","ζ","η","θ","ι","κ","λ","μ","ν","ξ","ο","π","ρ","σ","τ","υ","φ","χ","ψ","ω"];
// 注音符號
const BOPOMOFO = ["ㄅ","ㄆ","ㄇ","ㄈ","ㄉ","ㄊ","ㄋ","ㄌ","ㄍ","ㄎ","ㄏ","ㄐ","ㄑ","ㄒ","ㄓ","ㄔ","ㄕ","ㄖ","ㄗ","ㄘ","ㄙ","ㄚ","ㄛ","ㄜ","ㄝ","ㄞ","ㄟ","ㄠ","ㄡ","ㄢ","ㄣ","ㄤ","ㄥ","ㄦ","ㄧ","ㄨ","ㄩ","˙","ˊ","ˇ","ˋ"];
// 日文平假名
const HIRAGANA = ["あ","い","う","え","お","か","き","く","け","こ","が","ぎ","ぐ","げ","ご","さ","し","す","せ","そ","ざ","じ","ず","ぜ","ぞ","た","ち","つ","て","と","だ","ぢ","づ","で","ど","な","に","ぬ","ね","の","は","ひ","ふ","へ","ほ","ば","び","ぶ","べ","ぼ","ぱ","ぴ","ぷ","ぺ","ぽ","ま","み","む","め","も","や","ゆ","よ","ら","り","る","れ","ろ","わ","ゐ","ゑ","を","ん"];
// 日文片假名
const KATAKANA = ["ア","イ","ウ","エ","オ","カ","キ","ク","ケ","コ","ガ","ギ","グ","ゲ","ゴ","サ","シ","ス","セ","ソ","ザ","ジ","ズ","ゼ","ゾ","タ","チ","ツ","テ","ト","ダ","ヂ","ヅ","デ","ド","ナ","ニ","ヌ","ネ","ノ","ハ","ヒ","フ","ヘ","ホ","バ","ビ","ブ","ベ","ボ","パ","ピ","プ","ペ","ポ","マ","ミ","ム","メ","モ","ヤ","ユ","ヨ","ラ","リ","ル","レ","ロ","ワ","ヰ","ヱ","ヲ","ン"];
// 韓文元音與輔音符號（完整 Jamo 列表）
const KOREAN_JAMO = ["ㄱ","ㄲ","ㄳ","ㄴ","ㄵ","ㄶ","ㄷ","ㄸ","ㄹ","ㄺ","ㄻ","ㄼ","ㄽ","ㄾ","ㄿ","ㅀ","ㅁ","ㅂ","ㅃ","ㅄ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ","ㅏ","ㅐ","ㅑ","ㅒ","ㅓ","ㅔ","ㅕ","ㅖ","ㅗ","ㅘ","ㅙ","ㅚ","ㅛ","ㅜ","ㅝ","ㅞ","ㅟ","ㅠ","ㅡ","ㅢ","ㅥ","ㅦ","ㅧ","ㅨ","ㅩ","ㅪ","ㅫ","ㅬ","ㅭ","ㅮ","ㅯ","ㅰ","ㅱ","ㅲ","ㅳ","ㅴ","ㅵ","ㅶ","ㅷ","ㅸ","ㅹ","ㅺ","ㅻ","ㅼ","ㅽ","ㅾ","ㅿ","ㆀ","ㆁ","ㆂ","ㆃ","ㆄ","ㆅ","ㆆ","ㆇ","ㆈ","ㆉ","ㆊ"];
// 貨幣符號
const CURRENCY_SYMBOLS = ["¤","¢","$","฿","₫","৳","₭","₥","₱","₹","₨","₪","₸","₮","₩","¥","៛","₠","₯","€","ƒ","₣","₴","ℳ","₧","₰","£","₽","₳","₡","₢","₲","₵","₦"];
// 音樂符號
const MUSIC_SYMBOLS = ["♪","♫","♬","♭","♯","𝄞","𝄢","𝄫","♮","𝄪","𝄭","𝄮","𝄯","𝄰𝄱","𝄲","𝄳"];
// 國際象棋符號
const CHESS_SYMBOLS = ["♔","♕","♖","♗","♘","♙","♚","♛","♜","♝","♞","♟"];

// # 新增：生肖符號（十二生肖）
const CHINESE_ZODIAC = ["🐭","🐮","🐯","🐰","🐲","🐍","🐴","🐑","🐵","🐔","🐶","🐷"];
// # 新增：金庸小說十四部（飛雪連天射白鹿笑書神俠倚碧鴛）
const JINYONG_BOOKS = ["飛","雪","連","天","射","白","鹿","笑","書","神","俠","倚","碧","鴛"];
// # 新增：中文數字（大寫）
const CHINESE_BIG_NUMERALS = ["壹","貳","參","肆","伍","陸","柒","捌","玖","拾","佰","仟","萬","億","兆","圓","角","分","零","整"];

// # 新增：將日文和韓文符號拆分為 A、B 兩部分
const HIRAGANA_A = HIRAGANA.slice(0, Math.ceil(HIRAGANA.length / 2));
const HIRAGANA_B = HIRAGANA.slice(Math.ceil(HIRAGANA.length / 2));
const KATAKANA_A = KATAKANA.slice(0, Math.ceil(KATAKANA.length / 2));
const KATAKANA_B = KATAKANA.slice(Math.ceil(KATAKANA.length / 2));
const KOREAN_JAMO_A = KOREAN_JAMO.slice(0, Math.ceil(KOREAN_JAMO.length / 2));
const KOREAN_JAMO_B = KOREAN_JAMO.slice(Math.ceil(KOREAN_JAMO.length / 2));


const ALL_GAMES = [
    { name: "從 1～10 選出正確號碼", func: "game_guess_hidden" }, { name: "從 1～20 選出正確號碼", func: "game_guess_20" }, { name: "從 1～30 選出正確號碼", func: "game_guess_30" }, { name: "寶箱訓練：選出正確的", func: "game_treasure_box" }, { name: "選出好運表情符號", func: "game_emoji_pick" }, { name: "選出幸運動物", func: "game_animals" }, { name: "選出幸運食物", func: "game_foods" }, { name: "選出幸運地點", func: "game_places" }, { name: "選出幸運圖形", func: "game_shape_select" }, { name: "找出幸運顏色", func: "game_color_select" }, { name: "選出幸運國旗", func: "game_flags" }, { name: "選出幸運自然現象", func: "game_nature" }, { name: "選出幸運撲克牌符號", func: "game_cards" }, { name: "選出幸運麻將圖案", func: "game_mahjong" }, { name: "選出幸運交通工具", func: "game_vehicles" }, { name: "選出幸運星座符號", func: "game_zodiacs" }, { name: "禮物訓練：選出幸運禮物號碼", func: "game_gift_box" }, { name: "挑選今天幸運時段", func: "game_lucky_period" }, { name: "選出幸運職業", func: "game_professions" }, { name: "選出體育與獎項", func: "game_sports_awards" }, { name: "選出辦公文具A", func: "game_office_a" }, { name: "選出辦公文具B", func: "game_office_b" }, { name: "選出工具、家居用品及其他A", func: "game_tools_a" }, { name: "選出工具、家居用品及其他B", func: "game_tools_b" }, 
    { name: "羅馬數字（大寫）", func: "game_roman_u" }, { name: "羅馬數字（小寫）", func: "game_roman_l" }, { name: "數學符號", func: "game_math_symbols" }, { name: "單位符號", func: "game_unit_symbols" }, { name: "月份符號", func: "game_month_symbols" }, { name: "日期符號", func: "game_date_symbols" }, { name: "有襯線粗體英文字母（大寫）", func: "game_bold_serif_u" }, { name: "有襯線粗體英文字母（小寫）", func: "game_bold_serif_l" }, { name: "草書英文字母（大寫）", func: "game_script_u" }, { name: "草書英文字母（小寫）", func: "game_script_l" }, { name: "希臘字母（大寫）", func: "game_greek_u" }, { name: "希臘字母（小寫）", func: "game_greek_l" }, { name: "注音符號", func: "game_bopomofo" }, { name: "日文平假名", func: "game_hiragana" }, { name: "日文片假名", func: "game_katakana" }, { name: "韓文元音輔音", func: "game_korean_jamo" }, { name: "貨幣符號", func: "game_currency_symbols" }, { name: "音樂符號", func: "game_music_symbols" }, { name: "國際象棋符號", func: "game_chess_symbols" } ];


// ===================== 遊戲狀態管理 =====================
let gameState;
let maxScores;
let trainingState;
let timers = {
    answer: null,
    nextRound: null,
};

// 預設遊戲狀態
const defaultStats = {
    total: 0, exp: 0, bonus: 0, luck_tests_total: 0,
    luck_history: [], luck_tickets: 0, luck_tickets_total: 0,
    stage_idx: 0, last_daily_ticket_date: "", inventory: {},
    inventory_order: [], stones: 0, current_title: "1.宗門的基石",
    last_luck_date: "", last_luck_reward_msg: ""
    , personalName: ""
    , gender: ""
    , createDate: ""
    , linggen: null
};

function saveToLocalStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
        console.error("Failed to save to localStorage", e);
    }
}

function loadFromLocalStorage(key, defaultValue = {}) {
    const data = localStorage.getItem(key);
    try {
        return data ? JSON.parse(data) : defaultValue;
    } catch (e) {
        console.error("Failed to parse from localStorage", e);
        return defaultValue;
    }
}

function saveGameState() {
    saveToLocalStorage(STATS_FILE, gameState);
    saveToLocalStorage(SCORE_FILE, maxScores);
    // # 同步秘境試煉最高紀錄到 localStorage
    saveToLocalStorage(TRIAL_SCORE_FILE, maxTrialScores);
}

function loadGameState() {
    gameState = loadFromLocalStorage(STATS_FILE, JSON.parse(JSON.stringify(defaultStats)));
    maxScores = loadFromLocalStorage(SCORE_FILE, {});
    // # 載入秘境試煉最高紀錄，如果尚無則給空物件
    maxTrialScores = loadFromLocalStorage(TRIAL_SCORE_FILE, {});
    // 兼容舊版道具名稱
    const newInv = {};
    for (const [key, value] of Object.entries(gameState.inventory)) {
        const newName = ITEM_RENAME_MAP[key] || key;
        newInv[newName] = (newInv[newName] || 0) + value;
    }
    gameState.inventory = newInv;
    gameState.stage_idx = getStageIndex(gameState.exp);
}


// ===================== 核心邏輯函式 (移植自 Python) =====================
// 依據所需修煉經驗計算訓練次數門檻（十分之一，向上取整，至少為 1）。
// 例如需要 10 EXP 的層級，需要 1 次訓練；需要 25 EXP 的層級，需要 3 次訓練。
function getRequiredTrainingsForExp(needExp) {
    // needExp 可能為 undefined 或 0，皆返回 1
    if (!needExp || needExp <= 0) return 1;
    return Math.max(1, Math.ceil(needExp / 10));
}

function getStageIndex(exp) {
    // 根據經驗與訓練次數門檻判斷玩家當前修為層級。
    // 必須同時滿足經驗值與訓練次數條件才可進入下一層。
    let idx = 0;
    for (let i = 0; i < CULTIVATION_STAGES.length; i++) {
        const [need_exp] = CULTIVATION_STAGES[i];
        const requiredTrain = getRequiredTrainingsForExp(need_exp);
        if (exp >= need_exp && gameState.total >= requiredTrain) {
            idx = i;
        } else {
            break;
        }
    }
    return idx;
}

function getCultivationStage(exp) {
    return CULTIVATION_STAGES[getStageIndex(exp)][2];
}

function getNextCultivationInfo(exp) {
    // 根據經驗值與總訓練次數，計算距離下一層所需的經驗與訓練次數
    for (const [need_exp,, name] of CULTIVATION_STAGES) {
        const requiredTrain = getRequiredTrainingsForExp(need_exp);
        if (exp < need_exp || gameState.total < requiredTrain) {
            return {
                next_stage: name,
                exp_needed: Math.max(0, need_exp - exp),
                train_needed: Math.max(0, requiredTrain - gameState.total)
            };
        }
    }
    return null;
}

function getCultivationBonusExp(score, requiredScore) {
    const diff = score - requiredScore;
    if (diff < 5) return [0, ""];
    const capped = Math.min(diff, 95);
    const n = Math.floor(capped / 5);
    const exp = Math.pow(2, n - 1);
    return [Math.floor(exp), `分數超過門檻 ${capped} 分，獲得額外 +${Math.floor(exp)} 修煉經驗！`];
}

function getItemSortKey(itemName) {
    let itemType = '未知', itemGrade = '未知';
    for (const t of ITEM_TYPE_ORDER) {
        if (t === '兵器') {
            if (itemName.includes('劍') || itemName.includes('刀') || itemName.includes('槍')) {
                itemType = t; break;
            }
        } else if (itemName.includes(t)) {
            itemType = t; break;
        }
    }
    for (const g of GRADE_NAMES) {
        if (itemName.includes(g)) {
            itemGrade = g; break;
        }
    }
    const typeIndex = ITEM_TYPE_ORDER.includes(itemType) ? ITEM_TYPE_ORDER.indexOf(itemType) : ITEM_TYPE_ORDER.length;
    const gradeIndex = GRADE_NAMES.includes(itemGrade) ? GRADE_NAMES.indexOf(itemGrade) : GRADE_NAMES.length;
    return [typeIndex, gradeIndex, itemName];
}
// 比較道具名稱的函式：依照類型索引、品階索引、最後以名稱（字典序）排序。
// 與 8-8 版 Python get_item_sort_key 配合，避免使用 join 比對造成排序錯亂。
function compareItemNames(nameA, nameB) {
    const keyA = getItemSortKey(nameA);
    const keyB = getItemSortKey(nameB);
    // 先比類型
    if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
    // 再比品階
    if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
    // 最後比名稱
    return nameA.localeCompare(nameB, 'zh-Hant');
}

function getGradeByDifficulty(difficulty) {
    const idx = Math.max(0, Math.min(GRADE_NAMES.length - 1, difficulty - 1));
    return GRADE_NAMES[idx];
}


// ===================== 遊戲流程控制 =====================
const app = document.getElementById('app');
let temporaryMessages = []; // 用於顯示臨時訊息，例如每日獎勵

function clearApp() {
    app.innerHTML = '';
    Object.values(timers).forEach(timer => clearTimeout(timer));
}

function addTemporaryMessage(html, type) {
    temporaryMessages.push({ html, type });
}

function showTemporaryMessages() {
    temporaryMessages.forEach(({html, type}) => {
        const p = document.createElement('p');
        p.className = `message ${type}`;
        p.innerHTML = html;
        app.appendChild(p);
    });
    temporaryMessages = [];
}

function handleLevelUp(prevExp, newExp) {
    const prevIdx = getStageIndex(prevExp);
    const newIdx = getStageIndex(newExp);
    if (newIdx <= prevIdx) {
        gameState.stage_idx = newIdx;
        saveGameState();
        return "";
    }
    
    let ticketsGain = 0;
    for (let k = prevIdx + 1; k <= newIdx; k++) {
        const prevName = CULTIVATION_STAGES[k - 1][2];
        const match = prevName.match(/(\d+)層$/);
        ticketsGain += match ? parseInt(match[1], 10) : 1;
    }
    
    const stonesGain = newIdx - prevIdx;
    
    gameState.stage_idx = newIdx;
    gameState.luck_tickets += ticketsGain;
    gameState.luck_tickets_total += ticketsGain;
    gameState.stones += stonesGain;
    saveGameState();

    // 播放升級音效
    try {
        if (typeof playLevelUp === 'function') {
            playLevelUp();
        }
    } catch (e) {}
    
    let parts = [];
    if (ticketsGain > 0) parts.push(`+${ticketsGain} 票`);
    if (stonesGain > 0) parts.push(`+${stonesGain} 靈石`);

    return `🎟️ 升層獎勵：${parts.join('、')}（目前票 ${gameState.luck_tickets}，靈石 ${gameState.stones}）`;
}

function grantDailyTicketIfNeeded() {
    // 使用本地時間
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString().split('T')[0];

    if (gameState.last_daily_ticket_date !== today) {
        gameState.luck_tickets += 1;
        gameState.luck_tickets_total += 1;
        gameState.stones += 1;
        gameState.last_daily_ticket_date = today;
        saveGameState();
        addTemporaryMessage(`🎁 今日登入贈送 +1 測試機會及 +1 靈石（目前票 ${gameState.luck_tickets}，靈石 ${gameState.stones}）`, 'msg-daily');
    }
}

// ===================== 主選單渲染 =====================
// ===================== 靈根測試與個人資料 =====================
// # 提供初始設定介面，收集姓名與性別並啟動靈根測試
function showInitialSetup() {
    clearApp();
    let html = `<h1>🌱 靈根測試</h1>`;
    html += `<p style="text-align:center;">歡迎新修士！請填寫你的姓名與性別，再開始靈根測試。</p>`;
    html += `<p style="text-align:center;"><label>姓名：<input type="text" id="initial-name" placeholder="請輸入姓名" /></label></p>`;
    html += `<p style="text-align:center;"><label>性別：<select id="initial-gender"><option value="">未知</option><option value="男">男</option><option value="女">女</option><option value="其他">其他</option></select></label></p>`;
    html += `<button data-action="start-linggen-test">🌱 開始靈根測試</button>`;
    app.innerHTML = html;
}

// # 開始靈根測試：保存基本資料並從難度 1 測試起
function startLinggenTest() {
    try {
        const nameInput = document.getElementById('initial-name');
        const genderSelect = document.getElementById('initial-gender');
        const nameVal = nameInput ? nameInput.value.trim() : '';
        const genderVal = genderSelect ? genderSelect.value : '';
        gameState.personalName = nameVal || '無名修士';
        gameState.gender = genderVal || '';
        const todayStr = new Date().toISOString().slice(0,10);
        gameState.createDate = todayStr;
        gameState.linggen = null;
        saveGameState();
        if (typeof updateUserProfile === 'function') {
            try { updateUserProfile({ personalName: gameState.personalName, gender: gameState.gender, createDate: gameState.createDate }); } catch (e) {}
        }
    } catch (e) {}
    try {
        startTraining(1);
        if (trainingState) {
            trainingState.isLinggenTest = true;
            trainingState.linggenLevel = 1;
            trainingState.totalRounds = 1;
        }
    } catch (e) { console.warn('靈根測試啟動失敗', e); }
}

// # 對雲端使用者檔案進行合併更新
async function updateUserProfile(fields) {
    // 將使用者檔案資訊寫入 Supabase。當雲端未啟用時直接跳出。
    if (!ONLINE_ENABLED || !supabaseClient) return;
    try {
        const user = await ensureSignedIn();
        if (!user) return;
        // upsert 到 user_stats 表或其他表；此處假定 id 為主鍵
        await supabaseClient.from('user_stats').upsert(Object.assign({ id: user.id }, fields));
    } catch (e) {
        console.warn('更新使用者資料失敗', e);
    }
}
function renderMainMenu() {
    clearApp();
    grantDailyTicketIfNeeded();
    // # 若尚未設定姓名或尚未測試靈根，進入初始化流程
    if (!gameState.personalName || gameState.personalName === "" || gameState.linggen === null || gameState.linggen === undefined) {
        if (typeof showInitialSetup === 'function') {
            showInitialSetup();
            return;
        }
    }
    
    const highestScore = Object.keys(maxScores).length > 0 ? Math.max(...Object.values(maxScores)) : 0;
    const currentStage = getCultivationStage(gameState.exp);
    const nextInfo = getNextCultivationInfo(gameState.exp);
    
    let nextStageProgress = 100;
    let progressTip = "🌟 你已達到最終修為！";

    if (nextInfo) {
        progressTip = `⬆️ 距離「${nextInfo.next_stage}」還差 ${nextInfo.exp_needed} 修煉經驗、訓練 ${nextInfo.train_needed} 次`;
        let prevNeed = 0;
        for (const [need_exp] of CULTIVATION_STAGES) {
            if (gameState.exp >= need_exp) prevNeed = need_exp;
            else break;
        }
        let nextNeed = CULTIVATION_STAGES.find(([need_exp]) => gameState.exp < need_exp)?.[0];
        if (nextNeed !== undefined) {
            const span = Math.max(1, nextNeed - prevNeed);
            nextStageProgress = Math.floor((gameState.exp - prevNeed) * 100 / span);
        }
    }
    
    let html = `
        <h1>🎯 運氣訓練工具</h1>
        <h2>V2-13-S3（修仙網頁線上版）</h2>
        <!-- 顯示目前線上人數：透過 Supabase Presence 計算
             此段在 initPresence() 中會更新其文字內容 -->
        <p id="onlineUsersCount" style="text-align:center;">👥 目前線上人數：${onlineUsersCount}</p>
        <p style="text-align:center;">請選擇訓練難度（1 最簡單～10 最困難）</p>
    `;

    for (let i = 1; i <= 10; i++) {
        const score = maxScores[i] || 0;
        html += `<button data-action="start-training" data-level="${i}">難度 ${i}（最高分：${score}） 勝率：約 ${DIFFICULTY_WIN_RATE[i]}%</button>`;
    }

    // # 新增秘境試煉選項與排行榜：放置於難度 1~10 按鈕之後
    html += `<button data-action="render-secret-trial-menu">🌌 秘境試煉</button>`;
    html += `<button data-action="show-trial-leaderboard">🏆 秘境排行榜</button>`;


    html += `
        <div class="info-section">
            <p style="font-size: 1.2em; color: var(--teal-color);">🧘‍♂️ 目前修為：${currentStage}</p>
            <p style="font-size: 1.2em; color: var(--gold-color);">🎖️ 目前仙門位階：${gameState.current_title}</p>
            <p style="font-size: 0.9em; color: var(--secondary-color);">${progressTip}</p>
            <progress value="${nextStageProgress}" max="100"></progress>
            <p>🏋️ 累積訓練次數：${gameState.total} | ⚔️ 修煉經驗：${gameState.exp} | ⭐ 最高分：${highestScore}</p>
            <p>🎟️ 測試機會：${gameState.luck_tickets} 次 (累積獲得：${gameState.luck_tickets_total})</p>
            <p>💎 靈石：${gameState.stones}</p>
            <p>👤 姓名：${gameState.personalName || '未設定'} | 性別：${gameState.gender || '未設定'} | 🌱 靈根：${(gameState.linggen === undefined || gameState.linggen === null) ? '未測' : ((gameState.linggen <= 0) ? '無靈根' : gameState.linggen + ' 靈根')}</p>
        </div>
        <button data-action="show-stage-list">📜 查看修仙等級一覽</button>
        <button data-action="show-game-rules">📖 遊戲規則說明</button>
        <button data-action="show-rank-list">👑 查看仙門位階封號</button>
        <button data-action="show-backpack">🎒 背包</button>
        <button data-action="show-shop">🛒 商店</button>
        <button data-action="render-test-luck-menu">🔍 測試運氣</button>
        <button data-action="test-sfx">🔊 測試音效</button>
        <button data-action="show-login-menu">👤 帳號</button>
        <button class="btn-secondary" data-action="exchange-stones" data-count="1">🪙 兌換 1 靈石 (-${STONE_EXCHANGE_COST} EXP)</button>
        <button class="btn-secondary" data-action="exchange-stones" data-count="100">🪙 兌換 100 靈石 (-${STONE_100_EXCHANGE_COST} EXP)</button>
        <button class="btn-secondary" data-action="exchange-stones" data-count="1000">🪙 兌換 1000 靈石 (-${STONE_1000_EXCHANGE_COST} EXP)</button>
        <hr>
        <button class="btn-warning" data-action="reset-stats">歸零訓練/經驗統計</button>
        <button class="btn-danger" data-action="clear-scores">🗑️ 清除所有最高分紀錄</button>
    `;
    
    app.innerHTML = html;
    showTemporaryMessages();
    // 修補行動裝置箭頭圖示（用 SVG 替換）
    if (typeof patchLuckArrows === 'function') {
        try { patchLuckArrows(); } catch (e) {}
    }
}

// ===================== 訓練流程 =====================

function startTraining(level) {
    trainingState = {
        difficulty: level,
        round: 0,
        success: 0,
        fail: 0,
        totalRounds: 20,
        hasAnswered: false,
        correctAnswers: [],
        gameGridButtons: [],
        // Per-round state
        hasUsedSingleUseItem: false,
        allowedChoices: 1,
        selectedChoices: [],
    };
    // # 線上版新增：紀錄開始時間與本局使用道具清單（不影響舊版邏輯）
    try {
        trainingState.startedAt = Date.now();       // # 本局開始時間
        trainingState.usedItems = [];               // # 本局使用過的道具（兵器/功法/陣法）
    } catch (e) { /* # ignore */ }

    trainingNext();
}

function trainingNext() {
    if (trainingState.round >= trainingState.totalRounds) {
        timers.nextRound = setTimeout(showTrainingResult, 400);
        return;
    }
    trainingState.round++;
    
    // 重置每題狀態
    trainingState.hasAnswered = false;
    trainingState.hasUsedSingleUseItem = false;
    trainingState.allowedChoices = 1;
    trainingState.selectedChoices = [];
    // 本題額外時間重置
    trainingState.roundExtraTime = 0;
    // 重置倒數用的剩餘時間 (避免延續到下一題)
    trainingState.countdownRemaining = null;

    const gameDef = ALL_GAMES[Math.floor(Math.random() * ALL_GAMES.length)];
    const gameFunc = window[gameDef.func];
    gameFunc(); // This function will call renderTrainingScreen
}

function updateGameInfo() {
    const infoLabel = document.getElementById('game-info-label');
    if (infoLabel) {
        // # 若為秘境試煉模式，顯示當前題號、不顯示總題數，並額外顯示該難度最高答對題數
        if (trainingState.mode === 'secretTrial') {
            const best = (maxTrialScores && maxTrialScores[trainingState.difficulty]) ? maxTrialScores[trainingState.difficulty] : 0;
            infoLabel.innerHTML = `第 ${trainingState.round} 題 | ✅ 正確: ${trainingState.success} ❌ 錯誤: ${trainingState.fail} | 可選次數: ${trainingState.allowedChoices - trainingState.selectedChoices.length} | 🎯 最高：${best} 題`;
        } else if (trainingState.totalRounds === Infinity) {
            // # 其他無限回合模式（理論上不會用到），不顯示總題數
            infoLabel.innerHTML = `第 ${trainingState.round} 題 | ✅ 正確: ${trainingState.success} ❌ 錯誤: ${trainingState.fail} | 可選次數: ${trainingState.allowedChoices - trainingState.selectedChoices.length}`;
        } else {
            infoLabel.innerHTML = `第 ${trainingState.round}/${trainingState.totalRounds} 題 | ✅ 正確: ${trainingState.success} ❌ 錯誤: ${trainingState.fail} | 可選次數: ${trainingState.allowedChoices - trainingState.selectedChoices.length}`;
        }
    }
}

function renderTrainingScreen(title, items, correctAnswers, columns=5, btnSize=60) {
    clearApp();
    trainingState.correctAnswers = correctAnswers;
    
    let gridTemplateColumns = `repeat(${columns}, 1fr)`;

    let buttonsHTML = '';
    items.forEach((item) => {
        // Use data-choice to avoid issues with special characters in IDs
        buttonsHTML += `<button class="grid-btn" data-action="grid-btn" data-choice="${item}" style="height:${btnSize}px;">${item}</button>`;
    });

    app.innerHTML = `
        <p id="difficulty-info-label" style="text-align:center;"></p>
        <p id="game-info-label" style="text-align:center;"></p>
        <h3 style="text-align:center;">${title} (${correctAnswers.length} 個)</h3>
        <p id="feedback-label" class="feedback"></p>
        <p id="countdown-label" style="text-align:center; color:grey;"></p>
        <div class="game-grid" style="grid-template-columns: ${gridTemplateColumns};">
            ${buttonsHTML}
        </div>
        <div id="action-buttons">
            <button data-action="show-use-item-dialog">🎒 使用道具</button>
        </div>
    `;

    updateGameInfo();
    trainingState.gameGridButtons = Array.from(document.querySelectorAll('.grid-btn'));
    startAnswerCountdown(10);

    // 更新難度與下一階段門檻資訊
    const diffLabel = document.getElementById('difficulty-info-label');
    if (diffLabel) {
        const difficulty = trainingState.difficulty || 1;
        const nextInfoStage = getNextCultivationInfo(gameState.exp);
        if (nextInfoStage) {
            diffLabel.innerHTML = `難度 ${difficulty}｜下一階段「${nextInfoStage.next_stage}」門檻：還差 ${nextInfoStage.exp_needed} 修煉經驗、訓練 ${nextInfoStage.train_needed} 次`;
        } else {
            diffLabel.innerHTML = `難度 ${difficulty}｜已達最高階段`;
        }
    }
}

function onGridButtonClick(button) {
    if (trainingState.hasAnswered) return;

    if (trainingState.allowedChoices > 1) {
        const choice = button.dataset.choice;
        button.classList.toggle('checked');
        if (button.classList.contains('checked')) {
            if (trainingState.selectedChoices.length < trainingState.allowedChoices) {
                trainingState.selectedChoices.push(choice);
            } else {
                button.classList.remove('checked'); // Exceeded choices
            }
        } else {
            trainingState.selectedChoices = trainingState.selectedChoices.filter(c => c !== choice);
        }
        updateGameInfo();
        // 不再用「選滿就自動結束」，改由按下確認或倒數結束後作答
    } else {
        checkAnswerSingle(button.dataset.choice);
    }
}

function startAnswerCountdown(seconds) {
    // 本題倒數時間：基礎秒數 + roundExtraTime（上一題加時已在 trainingNext() 重置）
    let remaining = seconds + (trainingState.roundExtraTime || 0);
    // 使用 state 儲存剩餘秒數，方便在使用陣法時即時增加
    trainingState.countdownRemaining = remaining;
    const countdownLabel = document.getElementById('countdown-label');
    
    if (timers.answer) clearTimeout(timers.answer);

    const update = () => {
        // 若 UI 被切換就停止計時
        if (!document.getElementById('countdown-label')) return;
        // 若已回答則停表
        if (trainingState.hasAnswered) {
            countdownLabel.textContent = "作答結束";
            return;
        }
        // 以 state 中的剩餘秒數為準（可能被陣法中途加時修改）
        remaining = trainingState.countdownRemaining || 0;
        if (remaining >= 0) {
            countdownLabel.textContent = `作答倒數：${remaining} 秒`;
            trainingState.countdownRemaining = remaining - 1;
            timers.answer = setTimeout(update, 1000);
        } else {
            countdownLabel.textContent = "時間到！";
            if (trainingState.allowedChoices > 1) {
                checkAnswerMulti();
            } else {
                checkAnswerSingle(null); // null means timeout
            }
        }
    };
    update();
}

function checkAnswerSingle(choice) {
    if (trainingState.hasAnswered) return;
    trainingState.hasAnswered = true;
    
    const feedbackLabel = document.getElementById('feedback-label');
    let correct = false;

    if (choice === null) { // Timeout
        trainingState.fail++;
        feedbackLabel.innerHTML = `❌ 時間到！正確答案：${trainingState.correctAnswers.join(', ')}`;
        feedbackLabel.className = "feedback error";
        // # 在單題結束後標記這題為錯誤，用於秘境試煉判斷
        trainingState._lastCorrect = false;
    } else {
        correct = trainingState.correctAnswers.includes(choice);
        if (correct) {
            trainingState.success++;
            feedbackLabel.innerHTML = `✅ 恭喜你選對了！你選的是：${choice}`;
            feedbackLabel.className = "feedback success";
        } else {
            trainingState.fail++;
            feedbackLabel.innerHTML = `❌ 錯了，你選的是：${choice} 正確答案：${trainingState.correctAnswers.join(', ')}`;
            feedbackLabel.className = "feedback error";
        }
        // Query selector needs to handle special characters in data attributes
        document.querySelector(`.grid-btn[data-choice="${choice}"]`).classList.add('selected');
        // # 在單題結束後標記這題的對錯
        trainingState._lastCorrect = correct;
    }
    
    finalizeRound();
}

function checkAnswerMulti() {
    if (trainingState.hasAnswered) return;
    trainingState.hasAnswered = true;
    
    document.getElementById('confirm-btn')?.remove();

    const feedbackLabel = document.getElementById('feedback-label');
    const isCorrect = trainingState.selectedChoices.some(c => trainingState.correctAnswers.includes(c));
    // # 在結束後標記此題的對錯，供秘境試煉模式判斷
    trainingState._lastCorrect = isCorrect;

    if (isCorrect) {
        trainingState.success++;
        feedbackLabel.innerHTML = `✅ 答對了！你的選擇中包含了正確答案。`;
        feedbackLabel.className = "feedback success";
    } else {
        trainingState.fail++;
        feedbackLabel.innerHTML = `❌ 答錯了！正確答案是：${trainingState.correctAnswers.join(', ')}`;
        feedbackLabel.className = "feedback error";
    }
    finalizeRound();
}

function finalizeRound() {
    updateGameInfo();
    // 結算回合後清除本題加時，避免延續到下一題（雙重保障）
    trainingState.roundExtraTime = 0;
    // 清除倒數剩餘時間狀態
    trainingState.countdownRemaining = null;
    if (timers.nextRound) clearTimeout(timers.nextRound);
    // # 秘境試煉模式下，若答錯則結束並顯示試煉結果；若答對則繼續下一題
    if (trainingState.mode === 'secretTrial' || trainingState.totalRounds === Infinity) {
        if (trainingState._lastCorrect) {
            timers.nextRound = setTimeout(trialNext, 2000);
        } else {
            timers.nextRound = setTimeout(showTrialResult, 2000);
        }
    } else {
        timers.nextRound = setTimeout(trainingNext, 2000);
    }
}

function enterMultiChoiceMode() {
    if (trainingState.allowedChoices <= 1) return;
    if (document.getElementById('confirm-btn')) return;

    const confirmBtn = document.createElement('button');
    confirmBtn.id = 'confirm-btn';
    confirmBtn.textContent = '確認選擇';
    confirmBtn.dataset.action = "check-answer-multi";
    document.getElementById('action-buttons').appendChild(confirmBtn);
}


function showTrainingResult() {
    // # 若正在進行靈根測試，不計算經驗與訓練次數，直接根據答題結果判斷下一步
    if (trainingState && trainingState.isLinggenTest) {
        const wasCorrect = (trainingState.success >= trainingState.totalRounds);
        const currLv = trainingState.linggenLevel || trainingState.difficulty || 1;
        if (wasCorrect && currLv < 10) {
            // 前往下一難度測試
            startTraining(currLv + 1);
            if (trainingState) {
                trainingState.isLinggenTest = true;
                trainingState.linggenLevel = currLv + 1;
                trainingState.totalRounds = 1;
            }
        } else {
            // 測試結束，計算靈根
            let rootVal = wasCorrect ? currLv : (currLv - 1);
            if (rootVal < 0) rootVal = 0;
            gameState.linggen = rootVal;
            // 若尚未記錄初始日期，補錄
            if (!gameState.createDate) {
                gameState.createDate = new Date().toISOString().slice(0,10);
            }
            saveGameState();
            try {
                if (typeof updateUserProfile === 'function') {
                    updateUserProfile({ linggen: gameState.linggen, createDate: gameState.createDate, personalName: gameState.personalName, gender: gameState.gender });
                }
            } catch (e) {}
            const msg = (rootVal <= 0) ? '無靈根' : (rootVal + ' 靈根');
            showModal('🌱 靈根測試結果', `<p>你的靈根為：${msg}</p>`, `<button data-action="render-main-menu">確認</button>`);
        }
        return;
    }
    clearApp();
    const score = Math.floor((trainingState.success / trainingState.totalRounds) * 100);
    const prevTotalTrainCount = gameState.total;
    gameState.total++;

    if (score > (maxScores[trainingState.difficulty] || 0)) {
        maxScores[trainingState.difficulty] = score;
    }
    
    const required = DIFFICULTY_WIN_RATE[trainingState.difficulty] || 0;
    const [bonusExp, bonusMsg] = getCultivationBonusExp(score, required);
    const prevExp = gameState.exp;
    const baseExp = 1;
    const totalGain = baseExp + Math.max(0, bonusExp);
    gameState.exp += totalGain;
    if (bonusExp > 0) gameState.bonus = (gameState.bonus || 0) + bonusExp;

    // === 新增處罰機制 ===
    // 若得分低於該難度的勝率門檻，依差距扣減修煉值
    let penaltyMsg = "";
    if (score < required) {
        const diffLow = required - score;
        if (diffLow >= 5) {
            const steps = Math.floor(diffLow / 5);
            const penaltyPercent = Math.pow(2, steps - 1);
            let penaltyExp = Math.floor(gameState.exp * penaltyPercent / 100);
            if (penaltyExp > 0) {
                gameState.exp = Math.max(0, gameState.exp - penaltyExp);
                penaltyMsg = `❌ 分數低於門檻 ${diffLow} 分，扣除 ${penaltyExp} 修煉值 (${penaltyPercent}%)`;
            }
        }
    }

    // 在扣除處罰後進行升級判定
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    
    let resultHTML = `
        <h2>🏁 訓練完成</h2>
        <div class="feedback success">得分：${score} / 100</div>
        <p style="text-align:center;">💡 基本修煉經驗 +${baseExp}</p>
    `;
    if (bonusMsg) resultHTML += `<p style="text-align:center; color:green;">🎉 ${bonusMsg}</p>`;
    if (penaltyMsg) resultHTML += `<p style="text-align:center; color:red;">${penaltyMsg}</p>`;
    if (levelupMsg) resultHTML += `<p class="message msg-levelup">${levelupMsg}</p>`;

    let rewardsHTML = '';
    
    // 週期獎勵
    if (gameState.total > 0 && gameState.total % 5 === 0) {
        const [rewardsList] = grantRandomRewards(1);
        rewardsHTML += `<div class="message msg-reward">🎉 累積訓練達 ${gameState.total} 次，達成週期獎勵！<br>${rewardsList.join('<br>')}</div>`;
    }
    
    // 里程碑獎勵
    if (TRAINING_MILESTONES[gameState.total]) {
        const milestone = TRAINING_MILESTONES[gameState.total];
        gameState.current_title = milestone.title;
        const [rewardsList] = grantRandomRewards(milestone.rewards);
        rewardsHTML += `<div class="message msg-reward">🏆 恭喜！訓練達 ${gameState.total} 次，達成里程碑！<br>獲得新位階：【${milestone.title}】<br>獲得獎勵：<br>${rewardsList.join('<br>')}</div>`;
    }

    // 特定次數獎勵
    const countRewards = checkTrainingCountRewards(prevTotalTrainCount, gameState.total);
    if (countRewards) rewardsHTML += `<div class="message msg-reward">${countRewards}</div>`;

    // 靈石獎勵
    let stonesAward = 0;
    if (score >= 90) stonesAward = 3;
    else if (score >= 70) stonesAward = 2;
    else if (score >= 50) stonesAward = 1;
    if (score === 100) stonesAward += 3;
    const randomDrop = Math.random() < 0.10 ? 1 : 0;
    const totalStonesGain = stonesAward + randomDrop;
    if (totalStonesGain > 0) {
        gameState.stones += totalStonesGain;
        let parts = [];
        if (stonesAward > 0) parts.push(`根據表現獲得 ${stonesAward} 靈石`);
        if (randomDrop > 0) parts.push("偶遇驚喜：+1 靈石");
        rewardsHTML += `<p style="text-align:center; color:darkorchid">💎 ${parts.join('；')}</p>`;
    }

    // # 如果得分是 100 分，依照挑戰難度給予額外獎勵（難度越高獎勵越多）
    if (score === 100) {
        try {
            const diffLvl = trainingState.difficulty || 1;
            const [perfRewards] = grantRandomRewards(diffLvl);
            rewardsHTML += `<div class="message msg-reward">🌟 完美演出！難度 ${diffLvl} 完美答題，獲得 ${diffLvl} 份額外獎勵：<br>${perfRewards.join('<br>')}</div>`;
            // # 滿分達成時播放特殊獎勵音效（與樂透對獎中獎相似）
            try { if (typeof playRewardSound === 'function') playRewardSound(); } catch (_) {}
        } catch (e) { console.warn('滿分獎勵計算錯誤', e); }
    }

    saveGameState();
    // # 線上版新增：訓練結束時，上傳雲端紀錄（Firebase Firestore）
    try {
        if (typeof onGameFinished === 'function') {
            const _durationSec = Math.max(0, Math.floor((Date.now() - (trainingState.startedAt || Date.now())) / 1000));  // # 本局耗時（秒）
            const _result = (score >= (DIFFICULTY_WIN_RATE[trainingState.difficulty] || 0)) ? 'pass' : 'fail';             // # 是否達標
            const _usedItems = Array.isArray(trainingState.usedItems) ? trainingState.usedItems.slice(0) : [];            // # 使用道具清單（本局）
            onGameFinished({
                level: trainingState.difficulty,
                score: score,
                mode: '混合訓練',                 // # 目前題目混合（未細分各遊戲），後續可傳更精細的模式名稱
                usedItems: _usedItems,
                durationSec: _durationSec,
                result: _result,
                publishToLeaderboard: false     // # 預設不公開到排行榜；可在 UI 增加開關再改為 true
            });
        }
    } catch (e) { console.warn('上傳雲端失敗', e); }

    // 更新主畫面資訊，以反映處罰與獎勵
    if (typeof updateMainMenuInfo === 'function') {
        try { updateMainMenuInfo(); } catch (e) {}
    }
    
    const comment = commentForScore(score, required);

    resultHTML += rewardsHTML;
    resultHTML += `<p style="text-align:center; color:purple; font-style:italic;">"${comment}"</p>`;
    // # 新增再次挑戰按鈕：可直接重複目前難度之訓練
    resultHTML += `<button data-action="retry-training">🔄 再次挑戰</button>`;
    resultHTML += `<button data-action="render-main-menu">🔁 回主選單</button>`;
    app.innerHTML = resultHTML;
}

function checkTrainingCountRewards(prev, current) {
    let msg = [];
    const addItem = (itemName) => {
        gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + 1;
        if (!gameState.inventory_order.includes(itemName)) {
            gameState.inventory_order.push(itemName);
            gameState.inventory_order.sort((a, b) => {
                const keyA = getItemSortKey(a);
                const keyB = getItemSortKey(b);
                if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
                if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
                return a.localeCompare(b, 'zh-Hant');
            });
        }
    };

    if (prev < 100 && current >= 100) {
        const item = Math.random() < 0.5 ? "入品三才聚靈陣" : "入品四門陷敵陣";
        addItem(item);
        msg.push(`🎁 百煉成鋼！訓練達 100 次，領悟陣法：【${item}】`);
    }
    if (prev < 200 && current >= 200) {
        const item = Math.random() < 0.5 ? "入品築基吐納訣" : "入品松鹤長青功";
        addItem(item);
        msg.push(`🎁 道心穩固！訓練達 200 次，習得功法：【${item}】`);
    }
    if (prev < 500 && current >= 500) {
        const item = ["入品青竹劍", "入品銅背刀", "入品碎雲槍"][Math.floor(Math.random() * 3)];
        addItem(item);
        msg.push(`🎁 鋒芒初露！訓練達 500 次，獲得兵器：【${item}】`);
    }
    return msg.join('<br>');
}

function commentForScore(score, expected) {
    const diff = score - expected;
    const feedbacks = {
        95:"運氣超神，無人能敵！", 90:"運氣神化，無人能敵！", 85:"運氣爆棚，羨煞眾人！", 80:"天選之人，非你莫屬！", 75:"絕對的運氣掌握者！", 70:"運勢如虹，無人能擋。", 65:"強運來襲，勢不可擋。", 60:"你的運勢如日中天。", 55:"幸運星高照，前途似錦。", 50:"好運連連，勢頭正旺。", 45:"略勝一籌，前景可期。", 40:"實力與運氣兼具。", 35:"穩紮穩打，逐步晉升。", 30:"運氣尚佳，可再接再厲。", 25:"略高一線，尚有進步空間。", 20:"勉強超標，繼續努力。", 15:"稍稍領先，還需拼搏。", 10:"剛剛好過線，別鬆懈。", 5:"險中求勝，驚險過關。", 0:"中規中矩，剛好符合預期。",
        [-5]:"些微落後，調整心態。",[-10]:"差強人意，還需努力。",[-15]:"小有失利，穩住陣腳。", [-20]:"略低於平均，再接再厲。",[-25]:"運勢偏弱，繼續挑戰。",[-30]:"表現平平，需要加強。", [-35]:"稍嫌遜色，不如預期。",[-40]:"有點背運，振作起來。",[-45]:"運氣不濟，再戰一場。", [-50]:"明顯落後，重整旗鼓。",[-55]:"實力未展，下次再來。",[-60]:"狀況不佳，需要反思。", [-65]:"運氣低迷，注意轉運。",[-70]:"大幅失利，再接再厲。",[-75]:"今日不宜出門…", [-80]:"諸事不順，忍耐為上。",[-85]:"背運纏身，請小心行事。",[-90]:"極度背運，快去求神問卜。"
    };
    const closest = Object.keys(feedbacks).reduce((prev, curr) => Math.abs(curr - diff) < Math.abs(prev - diff) ? curr : prev);
    return feedbacks[closest] || "運勢未知，保持平常心。";
}


// ===================== 遊戲題庫生成 =====================
// ▼▼▼ MAJOR FIX: Corrected the logic to ensure answer positions are truly random. ▼▼▼
function game_template(title, pool, total, columns=5, btnSize=60) {
    // 1. 從題庫中隨機選出本次要顯示的所有選項
    const itemsForDisplay = [...pool].sort(() => 0.5 - Math.random()).slice(0, total);

    // 2. 決定正確答案的數量
    const correctCount = generateCorrectChoices(total);

    // 3. 從剛剛選出的選項中，**再次隨機挑選**出正確答案
    //    這是修正的核心，確保正確答案不是固定在前幾個
    const correctAnswers = [...itemsForDisplay].sort(() => 0.5 - Math.random()).slice(0, correctCount);

    // 4. 將隨機排列的選項和隨機選定的答案傳遞給渲染函式
    renderTrainingScreen(title, itemsForDisplay, correctAnswers, columns, btnSize);
}

function generateCorrectChoices(total) {
    const ratio = 1 - (trainingState.difficulty / 10);
    let correctCount = Math.max(1, Math.floor(total * ratio));
    if (trainingState.difficulty === 1 && correctCount === total) {
        correctCount--;
    }
    return correctCount;
}

// Assign game functions to the window object so they can be called by string name
window.game_guess_hidden = () => { const n = 10; game_template("從 1～10 選出正確號碼", Array.from({length: n}, (_, i) => String(i + 1)), n, 5); }
window.game_guess_20 = () => { const n = 20; game_template("從 1～20 選出正確號碼", Array.from({length: n}, (_, i) => String(i + 1)), n, 5); }
window.game_guess_30 = () => { const n = 30; game_template("從 1～30 選出正確號碼", Array.from({length: n}, (_, i) => String(i + 1)), n, 6); }
window.game_treasure_box = () => { const n = [10, 20, 30][Math.floor(Math.random()*3)]; game_template("寶箱訓練", Array.from({length: n}, (_, i) => String(i + 1)), n, n > 20 ? 6 : 5); }
window.game_gift_box = () => { const n = [10, 20, 30][Math.floor(Math.random()*3)]; game_template("禮物訓練", Array.from({length: n}, (_, i) => String(i + 1)), n, n > 20 ? 6 : 5); }
window.game_emoji_pick = () => { game_template("選出好運表情符號", EMOJIS, EMOJIS.length, 5); }
window.game_animals = () => { game_template("選出幸運動物", ANIMALS, ANIMALS.length, 5); }
window.game_foods = () => { game_template("選出幸運食物", FOODS, FOODS.length, 5); }
window.game_places = () => { game_template("選出幸運地點", PLACES, PLACES.length, 5); }
window.game_shape_select = () => { game_template("選出幸運圖形", SHAPES, SHAPES.length, 5); }
window.game_color_select = () => { game_template("找出幸運顏色", COLORS, COLORS.length, 5); }
window.game_flags = () => { game_template("選出幸運國旗", FLAGS, FLAGS.length, 5); }
window.game_nature = () => { game_template("選出幸運自然現象", NATURE, NATURE.length, 5); }
window.game_cards = () => { game_template("選出幸運撲克牌", CARDS, CARDS.length, 10, 48); }
window.game_mahjong = () => { game_template("選出幸運麻將", MAHJONG, MAHJONG.length, 7); }
window.game_vehicles = () => { game_template("選出幸運交通工具", VEHICLES, VEHICLES.length, 6); }
window.game_zodiacs = () => { game_template("選出幸運星座", ZODIACS, ZODIACS.length, 6); }
window.game_lucky_period = () => { game_template("挑選幸運時段", CLOCKS, CLOCKS.length, 6, 48); }
window.game_professions = () => { game_template("選出幸運職業", PROFESSIONS, PROFESSIONS.length, 7, 56); }
window.game_sports = () => { game_template("挑選運動與獎項", SPORTS, SPORTS.length, 6, 48); }
window.game_office = () => { game_template("挑選辦公文具", OFFICE, OFFICE.length, 6, 48); }
window.game_tools = () => { game_template("挑選工具、家居用品及其他", TOOLS, TOOLS.length, 6, 48); }

// 新增三種圖示訓練函式
// 自動拆分後的四個題庫函式
window.game_office_a = () => { game_template("選出辦公文具A", OFFICE_A, OFFICE_A.length, 6, 48); };
window.game_office_b = () => { game_template("選出辦公文具B", OFFICE_B, OFFICE_B.length, 6, 48); };
window.game_tools_a = () => { game_template("選出工具、家居用品及其他A", TOOLS_A, TOOLS_A.length, 6, 48); };
window.game_tools_b = () => { game_template("選出工具、家居用品及其他B", TOOLS_B, TOOLS_B.length, 6, 48); };

window.game_sports_awards = () => { game_template("選出體育與獎項", SPORTS, SPORTS.length, 6, 48); };
window.game_office_supplies = () => { game_template("選出辦公文具", OFFICE, OFFICE.length, 6, 48); };
window.game_tools_others = () => { game_template("選出工具、家居用品及其他", TOOLS, TOOLS.length, 6, 48); };

// # 新增符號類訓練遊戲函式
// # 羅馬數字（大寫）
window.game_roman_u = () => { game_template("羅馬數字（大寫）", ROMAN_U, ROMAN_U.length, 6); };
// # 羅馬數字（小寫）
window.game_roman_l = () => { game_template("羅馬數字（小寫）", ROMAN_L, ROMAN_L.length, 6); };
// # 數學符號
window.game_math_symbols = () => { game_template("數學符號", MATH_SYMBOLS, MATH_SYMBOLS.length, 6); };
// # 單位符號
window.game_unit_symbols = () => { game_template("單位符號", UNIT_SYMBOLS, UNIT_SYMBOLS.length, 6); };
// # 月份符號
window.game_month_symbols = () => { game_template("月份符號", MONTH_SYMBOLS, MONTH_SYMBOLS.length, 6); };
// # 日期符號
window.game_date_symbols = () => { game_template("日期符號", DATE_SYMBOLS, DATE_SYMBOLS.length, 6); };
// # 有襯線粗體英文字母（大寫）
window.game_bold_serif_u = () => { game_template("有襯線粗體英文字母（大寫）", BOLD_SERIF_U, BOLD_SERIF_U.length, 6); };
// # 有襯線粗體英文字母（小寫）
window.game_bold_serif_l = () => { game_template("有襯線粗體英文字母（小寫）", BOLD_SERIF_L, BOLD_SERIF_L.length, 6); };
// # 草書英文字母（大寫）
window.game_script_u = () => { game_template("草書英文字母（大寫）", SCRIPT_U, SCRIPT_U.length, 6); };
// # 草書英文字母（小寫）
window.game_script_l = () => { game_template("草書英文字母（小寫）", SCRIPT_L, SCRIPT_L.length, 6); };
// # 希臘字母（大寫）
window.game_greek_u = () => { game_template("希臘字母（大寫）", GREEK_U, GREEK_U.length, 6); };
// # 希臘字母（小寫）
window.game_greek_l = () => { game_template("希臘字母（小寫）", GREEK_L, GREEK_L.length, 6); };
// # 注音符號
window.game_bopomofo = () => { game_template("注音符號", BOPOMOFO, BOPOMOFO.length, 7, 48); };
// # 日文平假名
window.game_hiragana = () => { game_template("日文平假名", HIRAGANA, HIRAGANA.length, 8, 48); };
// # 日文片假名
window.game_katakana = () => { game_template("日文片假名", KATAKANA, KATAKANA.length, 8, 48); };
// # 韓文元音輔音
window.game_korean_jamo = () => { game_template("韓文元音輔音", KOREAN_JAMO, KOREAN_JAMO.length, 9, 48); };
// # 貨幣符號
window.game_currency_symbols = () => { game_template("貨幣符號", CURRENCY_SYMBOLS, CURRENCY_SYMBOLS.length, 6); };
// # 音樂符號
window.game_music_symbols = () => { game_template("音樂符號", MUSIC_SYMBOLS, MUSIC_SYMBOLS.length, 5); };
// # 國際象棋符號
window.game_chess_symbols = () => { game_template("國際象棋符號", CHESS_SYMBOLS, CHESS_SYMBOLS.length, 6); };

// # 新增：生肖符號遊戲
window.game_chinese_zodiacs = () => { game_template("生肖符號", CHINESE_ZODIAC, CHINESE_ZODIAC.length, 4, 48); };
// # 新增：金庸小說十四部遊戲
window.game_jinyong = () => { game_template("金庸小說14部", JINYONG_BOOKS, JINYONG_BOOKS.length, 7, 48); };
// # 新增：中文數字（大寫）遊戲
window.game_chinese_big_digits = () => { game_template("中文數字（大寫）", CHINESE_BIG_NUMERALS, CHINESE_BIG_NUMERALS.length, 6, 48); };
// # 新增：日文、韓文符號拆分後的遊戲定義
window.game_hiragana_a = () => { game_template("日文平假名A", HIRAGANA_A, HIRAGANA_A.length, 8, 48); };
window.game_hiragana_b = () => { game_template("日文平假名B", HIRAGANA_B, HIRAGANA_B.length, 8, 48); };
window.game_katakana_a = () => { game_template("日文片假名A", KATAKANA_A, KATAKANA_A.length, 8, 48); };
window.game_katakana_b = () => { game_template("日文片假名B", KATAKANA_B, KATAKANA_B.length, 8, 48); };
window.game_korean_jamo_a = () => { game_template("韓文字符號A", KOREAN_JAMO_A, KOREAN_JAMO_A.length, 9, 48); };
window.game_korean_jamo_b = () => { game_template("韓文字符號B", KOREAN_JAMO_B, KOREAN_JAMO_B.length, 9, 48); };

// # 調整遊戲列表：刪除原本的日文平假名、片假名、韓文元音輔音項目，並加入拆分版與新增的符號遊戲
(function() {
    try {
        if (Array.isArray(ALL_GAMES)) {
            const filtered = ALL_GAMES.filter(it => !['日文平假名', '日文片假名', '韓文元音輔音'].includes(it.name));
            filtered.push(
                { name: '日文平假名A', func: 'game_hiragana_a' },
                { name: '日文平假名B', func: 'game_hiragana_b' },
                { name: '日文片假名A', func: 'game_katakana_a' },
                { name: '日文片假名B', func: 'game_katakana_b' },
                { name: '韓文字符號A', func: 'game_korean_jamo_a' },
                { name: '韓文字符號B', func: 'game_korean_jamo_b' },
                { name: '生肖符號', func: 'game_chinese_zodiacs' },
                { name: '金庸小說14部', func: 'game_jinyong' },
                { name: '中文數字（大寫）', func: 'game_chinese_big_digits' }
            );
            ALL_GAMES.length = 0;
            filtered.forEach(it => ALL_GAMES.push(it));
        }
    } catch (e) {
        console.warn('ALL_GAMES modify failed', e);
    }
})();


// ===================== 測試運氣系統 =====================

function renderTestLuckMenu() {
    clearApp();
    grantDailyTicketIfNeeded();
    const tickets = gameState.luck_tickets;
    app.innerHTML = `
        <h2>🧪 測試你的運氣</h2>
        <div class="info-section" style="padding:10px;">
            <p>抽卡模式將隨機獲得修煉經驗、靈石、票券或道具。</p>
            <p>🎟️ 目前測試機會：${tickets} 次</p>
            <p>📅 今日運勢不消耗票。</p>
        </div>
        <button data-action="run-luck-draw" data-draws="1" data-mode="幸運抽卡單抽" ${tickets < 1 ? 'disabled' : ''}>🃏 單抽 (消耗 1 票)</button>
        <button data-action="run-luck-draw" data-draws="3" data-mode="幸運抽卡三抽" ${tickets < 3 ? 'disabled' : ''}>🃏 三抽 (消耗 3 票)</button>
        <button data-action="run-luck-draw" data-draws="10" data-mode="幸運抽卡10連抽" ${tickets < 10 ? 'disabled' : ''}>🃏 十連抽 (消耗 10 票)</button>
        <button data-action="run-luck-draw" data-draws="100" data-mode="幸運抽卡100連抽" ${tickets < 100 ? 'disabled' : ''}>🃏 百連抽 (消耗 100 票)</button>
        <button data-action="run-luck-draw" data-draws="1000" data-mode="幸運抽卡1000連抽" ${tickets < 1000 ? 'disabled' : ''}>🃏 千連抽 (消耗 1000 票)</button>
        <button data-action="run-luck-draw" data-draws="${tickets}" data-mode="幸運抽卡全部抽" ${tickets < 1 ? 'disabled' : ''}>🃏 全部抽 (消耗 ${tickets} 票)</button>
        <button data-action="run-today-luck">📅 今日運勢 (每日一次｜免費)</button>
        <hr>
        <button class="btn-secondary" data-action="redeem-tickets" data-pieces="1" data-cost="${REDEEM_1_COST}">🎫 兌換 1 張 (-${REDEEM_1_COST} EXP)</button>
        <button class="btn-secondary" data-action="redeem-tickets" data-pieces="10" data-cost="${REDEEM_10_COST}">🎫 兌換 10 張 (-${REDEEM_10_COST} EXP)</button>
        <button class="btn-secondary" data-action="redeem-tickets" data-pieces="100" data-cost="${REDEEM_100_COST}">🎫 兌換 100 張 (-${REDEEM_100_COST} EXP)</button>
        <button class="btn-secondary" data-action="redeem-tickets" data-pieces="1000" data-cost="${REDEEM_1000_COST}">🎫 兌換 1000 張 (-${REDEEM_1000_COST} EXP)</button>
        <hr>
        <button data-action="show-luck-history">📈 查看歷史與統計</button>
        <button data-action="render-main-menu">🔙 返回主選單</button>
    `;
    showTemporaryMessages();
    // 對行動裝置修補箭頭圖示
    if (typeof patchLuckArrows === 'function') {
        try { patchLuckArrows(); } catch (e) {}
    }
}

function redeemTickets(pieces, cost) {
    if (gameState.exp < cost) {
        addTemporaryMessage(`⚠️ EXP 不足 (需要 ${cost}，目前 ${gameState.exp})`, 'msg-shop-fail');
    } else {
        gameState.exp -= cost;
        gameState.luck_tickets += pieces;
        gameState.luck_tickets_total += pieces;
        addTemporaryMessage(`✅ 兌換成功：-${cost} EXP → +${pieces} 票`, 'msg-shop');
        saveGameState();
    }
    renderTestLuckMenu();
}

function runLuckDraw(draws, mode) {
    if (gameState.luck_tickets < draws || draws <= 0) {
        addTemporaryMessage(`⚠️ 測試機會不足！`, 'msg-shop-fail');
        renderTestLuckMenu();
        return;
    }
    gameState.luck_tickets -= draws;
    
    const [details, totals] = grantRandomRewards(draws);
    
    let summaryParts = [];
    if (totals.exp > 0) summaryParts.push(`+${totals.exp} EXP`);
    if (totals.stones > 0) summaryParts.push(`+${totals.stones} 靈石`);
    if (totals.tickets > 0) summaryParts.push(`+${totals.tickets} 票券`);
    if (Object.keys(totals.items).length > 0) {
        const totalItems = Object.values(totals.items).reduce((a, b) => a + b, 0);
        summaryParts.push(`+${totalItems} 件道具`);
    }

    const summaryMsg = summaryParts.length > 0 ? summaryParts.join('、') : "什麼都沒有...";
    addLuckHistory(mode, 0, "", totals.exp, summaryMsg);
    
    renderDrawResult(summaryMsg, details, mode, draws);
}

function addLuckHistory(mode, value, category, expGain, rewardMsg) {
    gameState.luck_tests_total++;
    gameState.luck_history.push({
        time: new Date().toLocaleString('sv-SE'), // YYYY-MM-DD HH:MM:SS
        mode, value, category, exp: expGain, reward_msg: rewardMsg
    });
    if (gameState.luck_history.length > 200) {
        gameState.luck_history.shift();
    }
    saveGameState();
}

function grantRandomRewards(count) {
    let rewardsList = [], totals = { exp: 0, stones: 0, tickets: 0, items: {} };
    
    const itemPool = Object.keys(ITEM_STONE_PRICES);
    const weights = itemPool.map(item => {
        const price = ITEM_STONE_PRICES[item] || 1;
        const grade = GRADE_NAMES.findIndex(g => item.startsWith(g)) + 1 || 1;
        return 1000 / (price * grade + 1);
    });

    const getScaledRandomAmount = (min, max) => {
        const bias_factor = Math.pow(gameState.stage_idx / CULTIVATION_STAGES.length, 2);
        const mode = min + (max - min) * bias_factor;
        const u = Math.random();
        // triangular distribution formula
        return Math.ceil(u < (mode - min) / (max - min) ? min + Math.sqrt(u * (max - min) * (mode - min)) : max - Math.sqrt((1 - u) * (max - min) * (max - mode)));
    };

    for (let i = 0; i < count; i++) {
        const rand = Math.random() * 100;
        let rewardType;
        if (rand < 40) rewardType = "exp";
        else if (rand < 70) rewardType = "stones";
        else if (rand < 85) rewardType = "tickets";
        else rewardType = "item";

        if (rewardType === 'exp') {
            const amount = getScaledRandomAmount(1, 1000);
            totals.exp += amount;
            rewardsList.push(`獲得 修煉經驗 +${amount}`);
        } else if (rewardType === 'stones') {
            const amount = getScaledRandomAmount(1, 100);
            totals.stones += amount;
            rewardsList.push(`獲得 靈石 +${amount}`);
        } else if (rewardType === 'tickets') {
            const amount = getScaledRandomAmount(1, 5);
            totals.tickets += amount;
            rewardsList.push(`獲得 票券 +${amount}`);
        } else if (rewardType === 'item') {
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let randWeight = Math.random() * totalWeight;
            let itemName = itemPool[itemPool.length - 1];
            for(let j=0; j<weights.length; j++){
                if(randWeight < weights[j]){
                    itemName = itemPool[j];
                    break;
                }
                randWeight -= weights[j];
            }
            const amount = getScaledRandomAmount(1, 10);
            totals.items[itemName] = (totals.items[itemName] || 0) + amount;
            rewardsList.push(`獲得 道具 [${itemName}] ×${amount}`);
        }
    }

    const prevExp = gameState.exp;
    gameState.exp += totals.exp;
    gameState.stones += totals.stones;
    gameState.luck_tickets += totals.tickets;
    Object.entries(totals.items).forEach(([name, qty]) => {
        gameState.inventory[name] = (gameState.inventory[name] || 0) + qty;
         if (!gameState.inventory_order.includes(name)) gameState.inventory_order.push(name);
    });
    if(Object.keys(totals.items).length > 0){
        gameState.inventory_order.sort((a,b) => compareItemNames(a,b));
    }

    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    if (levelupMsg) rewardsList.push(`<span class="msg-levelup">${levelupMsg}</span>`);
    
    saveGameState();
    return [rewardsList, totals];
}

function runTodayLuck() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString().split('T')[0];

    if (gameState.last_luck_date === today) {
        showTodayLuckResult(true);
        return;
    }

    const [rewardsList, totals] = grantRandomRewards(1);
    const rewardMsg = rewardsList[0] || "今日平淡無奇...";

    gameState.last_luck_date = today;
    gameState.last_luck_reward_msg = rewardMsg;

    addLuckHistory("今日運勢", 0, "動態獎勵", totals.exp, rewardMsg);
    showTodayLuckResult(false);
}

function renderDrawResult(summary, details, mode, draws) {
    clearApp();
    const currentStage = getCultivationStage(gameState.exp);
    
    app.innerHTML = `
        <h2>🃏 ${mode} 結果</h2>
        <div class="feedback info">🎁 總計：${summary}</div>
        <div style="height: 150px; overflow-y:auto; border:1px solid #ccc; padding:10px; border-radius:6px; margin-bottom:15px;">
            ${details.join('<br>')}
        </div>
        <div class="info-section" style="padding:10px;">
            <p style="font-size: 1.1em; color: var(--teal-color);">🧘‍♂️ 目前修為：${currentStage}</p>
            <p>累積 EXP：${gameState.exp}</p>
        </div>
        <button data-action="run-luck-draw" data-draws="${draws}" data-mode="${mode}" ${gameState.luck_tickets < draws ? 'disabled' : ''}>🔁 再來一次 (${draws} 票)</button>
        <button data-action="show-luck-history">📈 查看歷史與統計</button>
        <button data-action="render-test-luck-menu">🔙 返回測試選單</button>
        <button data-action="render-main-menu">🏠 回主選單</button>
    `;
}

function showTodayLuckResult(isRepeat) {
    clearApp();
    const luckySuggestion = () => {
        const seed = parseInt(new Date().toISOString().slice(0, 10).replace(/-/g, ''), 10);
        const rng = (s) => () => { s = Math.sin(s) * 10000; return s - Math.floor(s); };
        const rand = rng(seed);
        const lucky_num = Math.floor(rand() * 39) + 1;
        const lucky_color = COLORS[Math.floor(rand() * COLORS.length)];
        const lucky_emoji = EMOJIS[Math.floor(rand() * EMOJIS.length)];
        const lucky_dir = ["上", "下", "左", "右", "左上", "右上", "右下", "左下"][Math.floor(rand() * 8)];
        return `幸運號碼：${lucky_num} | 幸運色：${lucky_color} | 幸運表情：${lucky_emoji} | 幸運方位：${lucky_dir}`;
    };

    app.innerHTML = `
        <h2>📅 今日運勢</h2>
        <div class="feedback" style="color:darkorange">${isRepeat ? '(今日已測) ' : ''}${gameState.last_luck_reward_msg}</div>
        <p style="text-align:center;">${luckySuggestion()}</p>
        <div class="info-section" style="padding:10px;">
            <p style="font-size: 1.1em; color: var(--teal-color);">🧘‍♂️ 目前修為：${getCultivationStage(gameState.exp)}</p>
        </div>
        <button data-action="render-test-luck-menu">🔙 返回測試選單</button>
        <button data-action="render-main-menu">🏠 回主選單</button>
    `;
}

// ===================== 雜項功能 & 重置 =====================
function exchangeStones(count) {
    const cost = STONE_EXCHANGE_COST * count;
    if (gameState.exp < cost) {
        addTemporaryMessage(`⚠️ EXP 不足，無法兌換`, 'msg-shop-fail');
    } else {
        gameState.exp -= cost;
        gameState.stones += count;
        handleLevelUp(gameState.exp + cost, gameState.exp); // Recalculate level
        addTemporaryMessage(`✅ 兌換成功：-${cost} EXP → +${count} 靈石`, 'msg-shop');
        saveGameState();
    }
    renderMainMenu();
}

function resetTrainingStats() {
    if (confirm("確定要歸零所有訓練統計、經驗、道具和等級嗎？此操作無法復原。")) {
        gameState = JSON.parse(JSON.stringify(defaultStats));
        saveGameState();
        renderMainMenu();
    }
}

function clearMaxScores() {
    if (confirm("確定要清除所有難度的最高分紀錄嗎？此操作無法復原。")) {
        maxScores = {};
        saveGameState();
        renderMainMenu();
    }
}


// ===================== Modal (彈出視窗) 系統 =====================
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modal-title');
const modalBody = document.getElementById('modal-body');
const modalFooter = document.getElementById('modal-footer');
const modalCloseBtn = document.getElementById('modal-close-btn');

modalCloseBtn.onclick = () => modal.style.display = "none";
window.onclick = (event) => {
    if (event.target == modal) {
        modal.style.display = "none";
    }
}

function showModal(title, bodyHTML, footerHTML = '') {
    modalTitle.textContent = title;
    modalBody.innerHTML = bodyHTML;
    modalFooter.innerHTML = footerHTML;
    modal.style.display = "flex";
}

function showStageList() {
    // 列出各層級所需的修煉經驗與訓練次數門檻
    const content = CULTIVATION_STAGES.map(([exp,, name]) => {
        const requiredTrain = getRequiredTrainingsForExp(exp);
        return `<li><b>${name}</b>：需修煉經驗 ${exp}，訓練次數門檻 ${requiredTrain}</li>`;
    }).join('');
    showModal("修仙等級一覽表", `<ul style="padding-left: 20px;">${content}</ul>`, `<button data-action="close-modal">關閉</button>`);
}

function showRankList() {
    let content = '仙門位階是根據您的總訓練次數授予的榮譽稱號：<br><br><ul style="padding-left: 20px;">';
    content += Object.entries(TRAINING_MILESTONES).map(([count, data]) => `<li>訓練 <b>${count}</b> 次：授予位階【${data.title}】</li>`).join('');
    showModal("仙門位階封號一覽表", `${content}</ul>`, `<button data-action="close-modal">關閉</button>`);
}

function showLuckHistory() {
    let content = '';
    if (!gameState.luck_history || gameState.luck_history.length === 0) {
      content = "尚無歷史紀錄。";
    } else {
      const totalExp = gameState.luck_history.reduce((s, h) => s + (h.exp || 0), 0);
      content += `<p><b>累積經驗 +${totalExp}</b></p><hr>`;
      content += '<ul style="padding-left: 20px; word-break: break-all;">';
      gameState.luck_history.slice().reverse().slice(0, 50).forEach(h => {
        content += `<li>[${h.time}] <b>${h.mode}</b> → ${h.reward_msg || `${h.value} (${h.category})`} (EXP +${h.exp})</li>`;
      });
      content += '</ul>';
    }
    showModal("測試運氣歷史", content, `<button data-action="close-modal">關閉</button>`);
}

// 遊戲規則說明：詳細說明升級獎勵、關卡、道具功能以及處罰機制。
// # 新增遊戲規則說明按鈕對應的函式
function showGameRules() {
    /* # 遊戲規則：
       1. 升級獎勵說明：當你的修煉經驗與訓練次數同時達到下一層門檻，
          修為會自動突破。每突破一層，將獲得一定數量的測試機會與靈石獎勵。
       2. 遊戲關卡說明：訓練共有 10 種難度，每回合包含 20 題圖示，請在倒數時間內選出目標。答對可累積修煉經驗與訓練次數，達到該難度要求的勝率可獲得額外經驗加成。
       3. 道具升級及功能說明：道具分為兵器、功法、陣法、靈器、靈符、仙丹等類：
          - 兵器：增加可選答案數，可在多選題中使用；
          - 功法：排除部分錯誤答案；
          - 陣法：增加當題作答時間；
          - 靈器：顯示全部正確答案；
          - 靈符：顯示部分錯誤答案；
          - 仙丹：立即增加修煉經驗。
          道具可以在商店購買，或透過消耗靈石升級為更高品階，效果將更強。升級消耗的靈石會即時扣除並更新顯示。
       4. 處罰機制：若訓練結束時得分低於該難度要求的勝率門檻，將扣減修煉經驗。差距每增加 5 分，處罰率翻倍：差 5 分扣 1%，差 10 分扣 2%，差 15 分扣 4%，差 20 分扣 8%，差 25 分扣 16%，差 30 分扣 32%，以此類推。當修煉經驗為 0 時不再扣減。*/
    const content = `
        <div style="text-align:left;">
            <h3>1. 升級獎勵說明</h3>
            <p>當你的修煉經驗與訓練次數同時達到下一層門檻時，修為會自動突破。每突破一層，依據突破層級差距獲得相應數量的測試機會與靈石。</p>
            <h3>2. 遊戲關卡說明</h3>
            <p>訓練共有 10 個難度，每回合包含 20 題圖示，請在倒數時間內選出目標。答對能累積修煉經驗與訓練次數；達到該難度要求的勝率，可額外獲得修煉經驗獎勵。</p>
            <h3>3. 道具升級及功能說明</h3>
            <p>道具分為兵器、功法、陣法、靈器、靈符、仙丹等類，每種道具功能如下：</p>
            <ul>
                <li><b>兵器</b>：增加可選答案數，可用於多選題。</li>
                <li><b>功法</b>：排除部分錯誤答案。</li>
                <li><b>陣法</b>：增加作答時間，僅對當題有效。</li>
                <li><b>靈器</b>：顯示全部正確答案。</li>
                <li><b>靈符</b>：顯示部分錯誤答案。</li>
                <li><b>仙丹</b>：立即增加修煉經驗。</li>
            </ul>
            <p>道具可在商店購買，或使用靈石進行升級以提升效果。升級時消耗的靈石會即刻從你的帳戶扣除並刷新主畫面。</p>
            <h3>4. 處罰機制</h3>
            <p>若訓練結算得分低於該難度要求的勝率門檻，你的修煉經驗將被扣減。與門檻差距每增加 5 分，處罰率翻倍：差 5 分扣 1%，差 10 分扣 2%，差 15 分扣 4%，差 20 分扣 8%，差 25 分扣 16%，差 30 分扣 32%，依此類推。當修煉經驗為 0 時不再扣減。</p>

            <h3>5. 完美與秘境獎勵</h3>
            <p>在普通訓練中，若在 20 題中取得 100 分滿分，將根據挑戰難度額外獲得隨機獎勵：難度 1 時額外 1 份獎勵，難度 2 時 2 份，以此類推。</p>
            <p>在秘境試煉中，若本次連續答對題數超越既往最高紀錄，將獲得額外獎勵，新紀錄越高獎勵越豐厚。每突破 100 題將額外增加 2 份獎勵，超越 500 題以上可獲得更多倍獎勵。</p>
            <p>進入秘境試煉需要消耗靈石：秘境難度 1 消耗 10 顆靈石，之後每提高 1 級所需消耗翻倍。例如難度 2 消耗 20 顆，難度 3 消耗 40 顆。</p>
        </div>
    `;
    showModal("📜 遊戲規則說明", content, `<button data-action="close-modal">關閉</button>`);
}

// ===================== 秘境試煉與排行榜 / 登入系統 =====================

// # 秘境試煉主選單：讓玩家挑選難度後開始秘境試煉
function renderSecretTrialMenu() {
    clearApp();
    // 在渲染秘境選單前，重新讀取本地秘境紀錄，確保按鈕上顯示的最高答題數最新
    try {
        maxTrialScores = loadFromLocalStorage(TRIAL_SCORE_FILE, maxTrialScores || {});
    } catch (e) { /* ignore */ }
    let html = `<h1>🌌 秘境試煉</h1>`;
    html += `<p style="text-align:center;">請選擇秘境難度（1 最簡單～10 最困難）</p>`;
    for (let i = 1; i <= 10; i++) {
        const best = maxTrialScores[i] || 0;
        // # 每個秘境難度的消耗：難度 1 為 10 顆靈石，之後每一級翻倍
        const cost = 10 * Math.pow(2, i - 1);
        // # 將所需靈石與最高答對題數標註在按鈕文字中
        html += `<button data-action="start-trial" data-level="${i}">秘境難度 ${i}（${cost}靈石）(最高答對：${best} 題)</button>`;
    }
    html += `<button data-action="render-main-menu">🔙 返回主選單</button>`;
    app.innerHTML = html;
}

// # 開始秘境試煉：題數無限制，直到答錯為止
function startTrial(level) {
    // # 進入秘境試煉需消耗靈石：難度 1 消耗 10，之後每提高 1 級需求翻倍
    try {
        var cost = 10 * Math.pow(2, (level - 1));
        // # 若靈石不足則拒絕進入試煉
        if (typeof gameState !== 'undefined' && gameState.stones < cost) {
            alert('💎 靈石不足，無法進入秘境試煉！');
            return;
        }
        if (typeof gameState !== 'undefined') {
            gameState.stones -= cost;
            try { saveGameState(); } catch (e) {}
            // # 更新主畫面顯示靈石數量（若可用）
            if (typeof updateMainMenuInfo === 'function') {
                try { updateMainMenuInfo(); } catch (e) {}
            }
        }
    } catch (e) {}
    trainingState = {
        mode: 'secretTrial',
        difficulty: level,
        round: 0,
        success: 0,
        fail: 0,
        totalRounds: Infinity,
        hasAnswered: false,
        correctAnswers: [],
        gameGridButtons: [],
        hasUsedSingleUseItem: false,
        allowedChoices: 1,
        selectedChoices: [],
    };
    // # 記錄開始時間與使用過的道具
    try {
        trainingState.startedAt = Date.now();
        trainingState.usedItems = [];
    } catch (e) {}
    trialNext();
}

// # 秘境試煉下一題：類似於 trainingNext，但沒有題數限制
function trialNext() {
    trainingState.round++;
    // 重置每題狀態
    trainingState.hasAnswered = false;
    trainingState.hasUsedSingleUseItem = false;
    trainingState.allowedChoices = 1;
    trainingState.selectedChoices = [];
    trainingState.roundExtraTime = 0;
    trainingState.countdownRemaining = null;
    const gameDef = ALL_GAMES[Math.floor(Math.random() * ALL_GAMES.length)];
    const gameFunc = window[gameDef.func];
    gameFunc();
}

// # 秘境試煉結束與獎勵結算
function showTrialResult() {
    clearApp();
    const correctCount = trainingState.success || 0;
    // 記錄最高紀錄
    const diff = trainingState.difficulty;
    const prevBestTrial = maxTrialScores[diff] || 0;
    if (!maxTrialScores[diff] || correctCount > maxTrialScores[diff]) {
        maxTrialScores[diff] = correctCount;
        // # 儲存到 localStorage
        try { saveToLocalStorage(TRIAL_SCORE_FILE, maxTrialScores); } catch (e) {}
    }
    const prevTotalTrainCount = gameState.total;
    gameState.total++;
    // 基礎經驗
    const baseExp = 1;
    // 額外經驗：每 10 題 +1
    const bonusExp = Math.floor(correctCount / 10);
    const prevExp = gameState.exp;
    gameState.exp += baseExp + bonusExp;
    if (bonusExp > 0) gameState.bonus = (gameState.bonus || 0) + bonusExp;
    // 發放隨機獎勵：每 20 題 1 個
    let rewardsHTML = '';
    const rewardCount = Math.floor(correctCount / 20);
    if (rewardCount > 0) {
        const rewardsList = grantRandomRewards(rewardCount)[0];
        rewardsHTML += `<div class="message msg-reward">🎁 秘境表現獲得 ${rewardCount} 個隨機獎勵：<br>${rewardsList.join('<br>')}</div>`;
    }
    // 當超過過往最高紀錄時，給予額外獎勵，難度越高、答對越多題，獎勵越多
    let recordRewardHTML = '';
    try {
        if (correctCount > prevBestTrial) {
            // # 設定超越紀錄的獎勵數量：基於新紀錄的題數，每 100 題增加 2 份獎勵
            const rewardCountRecord = 1 + Math.floor(correctCount / 100) * 2;
            const [recordRewards] = grantRandomRewards(rewardCountRecord);
            recordRewardHTML = `<div class="message msg-reward">🏅 超越歷史紀錄！獲得 ${rewardCountRecord} 個額外獎勵：<br>${recordRewards.join('<br>')}</div>`;
        }
    } catch (e) { console.warn('紀錄獎勵計算錯誤', e); }

    // 發放靈石：每 30 題 1 顆
    const stonesAward = Math.floor(correctCount / 30);
    if (stonesAward > 0) {
        gameState.stones += stonesAward;
        rewardsHTML += `<p style="text-align:center; color:darkorchid">💎 秘境表現獲得 ${stonesAward} 靈石</p>`;
    }

    // # 若這次答題數超過以往最高紀錄，將紀錄獎勵加入顯示
    if (recordRewardHTML) {
        rewardsHTML += recordRewardHTML;
        // # 播放特殊獎勵音效（與樂透對獎中獎相似）
        try { if (typeof playRewardSound === 'function') playRewardSound(); } catch (_) {}
    }

    // =============== 訓練次數獎勵與仙門位階更新 ===============
    // # 在秘境試煉中也計算週期獎勵、里程碑獎勵以及特定次數獎勵，與普通訓練相同
    try {
        if (gameState.total > 0 && gameState.total % 5 === 0) {
            const [cycleRewards] = grantRandomRewards(1);
            rewardsHTML += `<div class="message msg-reward">🎉 累積訓練達 ${gameState.total} 次，達成週期獎勵！<br>${cycleRewards.join('<br>')}</div>`;
        }
        if (TRAINING_MILESTONES[gameState.total]) {
            const milestone = TRAINING_MILESTONES[gameState.total];
            gameState.current_title = milestone.title;
            const [milestoneRewards] = grantRandomRewards(milestone.rewards);
            rewardsHTML += `<div class="message msg-reward">🏆 恭喜！訓練達 ${gameState.total} 次，達成里程碑！<br>獲得新位階：【${milestone.title}】<br>獲得獎勵：<br>${milestoneRewards.join('<br>')}</div>`;
        }
        const countRewards = checkTrainingCountRewards(prevTotalTrainCount, gameState.total);
        if (countRewards) rewardsHTML += `<div class="message msg-reward">${countRewards}</div>`;
    } catch (e) { console.warn('秘境訓練獎勵錯誤', e); }

    // 升級判定
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    let resultHTML = `<h2>🌌 秘境試煉完成</h2>`;
    resultHTML += `<div class="feedback success">連續答對題數：${correctCount}</div>`;
    resultHTML += `<p style="text-align:center;">💡 修煉經驗 +${baseExp + bonusExp}</p>`;
    if (levelupMsg) resultHTML += `<p class="message msg-levelup">${levelupMsg}</p>`;
    resultHTML += rewardsHTML;
    // 顯示回主選單按鈕
    // # 新增再次挑戰按鈕：若靈石足夠，則可再次挑戰本難度
    try {
        const diff = trainingState.difficulty || 1;
        const cost = 10 * Math.pow(2, diff - 1);
        const disabledAttr = (typeof gameState !== 'undefined' && gameState.stones < cost) ? 'disabled' : '';
        resultHTML += `<button data-action="retry-trial" data-level="${diff}" ${disabledAttr}>🔄 再次挑戰</button>`;
    } catch (e) {
        // 若出現錯誤仍顯示可再次挑戰
        resultHTML += `<button data-action="retry-trial">🔄 再次挑戰</button>`;
    }
    resultHTML += `<button data-action="render-main-menu">🔁 回主選單</button>`;
    app.innerHTML = resultHTML;
    saveGameState();
    // # 上傳秘境紀錄至雲端 (Firestore)
    try {
        if (typeof saveTrialRecord === 'function') {
            const _durationSec = Math.max(0, Math.floor((Date.now() - (trainingState.startedAt || Date.now())) / 1000));
            const _usedItems = Array.isArray(trainingState.usedItems) ? trainingState.usedItems.slice(0) : [];
            saveTrialRecord({
                level: trainingState.difficulty,
                score: correctCount,
                mode: '秘境試煉',
                usedItems: _usedItems,
                durationSec: _durationSec,
                result: 'fail',
                publishToLeaderboard: true
            });
        }
    } catch (e) { console.warn('saveTrialRecord failed', e); }
    // 更新主畫面資訊
    if (typeof updateMainMenuInfo === 'function') {
        try { updateMainMenuInfo(); } catch(e) {}
    }
}

// # 將秘境試煉紀錄寫入雲端：
async function saveTrialRecord(rec) {
    // rec: { level, score, mode, usedItems, durationSec, result, publishToLeaderboard }
    if (!FIREBASE_ONLINE_ENABLED || !db) return;
    var u = auth && auth.currentUser ? auth.currentUser : await ensureSignedIn();
    if (!u) return;
    var uid = u.uid;
    var now = firebase.firestore.Timestamp.now();
    var runRef = db.collection('users').doc(uid).collection('trials').doc();
    var statRef = db.collection('user_trial_stats').doc(uid);
    return db.runTransaction(async function(tx) {
        tx.set(runRef, Object.assign({}, rec, {
            createdAt: now,
            clientAt: new Date().toISOString(),
            appVersion: 'web-1.0.0'
        }));
        var statSnap = await tx.get(statRef);
        var prev = statSnap.exists ? statSnap.data() : { totalTrials: 0, bestScore: -1 };
        var next = {
            totalTrials: (prev.totalTrials || 0) + 1,
            bestScore: Math.max(prev.bestScore || -1, rec.score || 0),
            lastPlayedAt: now
        };
        tx.set(statRef, next, { merge: true });
    }).then(async function() {
        // # 更新公開排行榜：加入或更新各難度最高答對題數與玩家基本資料
        if (rec.publishToLeaderboard) {
            try {
                var prof = await getOrInitUserProfile();
                var leaderRef = db.collection('leaderboard_trial_public').doc(uid);
                await db.runTransaction(async function(tx2) {
                    var snap = await tx2.get(leaderRef);
                    var data = snap.exists ? snap.data() : {};
                    var bestScores = Object.assign({}, data.bestScores || {});
                    // # 更新當前難度最高分
                    var prevScore = bestScores[rec.level] || 0;
                    var newScore = Math.max(prevScore, rec.score || 0);
                    bestScores[rec.level] = newScore;
                    // # 全域最高分
                    var bestScoreOverall = data.bestScore || 0;
                    bestScoreOverall = Math.max(bestScoreOverall, rec.score || 0);
                    // # 構建更新資料
                    var updateData = {
                        bestScores: bestScores,
                        // # 同步一份到 bestByLevel 供舊版讀取
                        bestByLevel: bestScores,
                        bestScore: bestScoreOverall,
                        displayName: (prof.personalName && prof.personalName !== '') ? prof.personalName : (prof.displayName || '無名修士'),
                        gender: prof.gender || '',
                        linggen: (typeof prof.linggen !== 'undefined' ? prof.linggen : ((typeof gameState !== 'undefined' && gameState.linggen !== undefined) ? gameState.linggen : null)),
                        createDate: prof.createDate || firebase.firestore.FieldValue.serverTimestamp(),
                        country: prof.country || 'TW',
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    tx2.set(leaderRef, updateData, { merge: true });
                });
            } catch (e) {
                console.warn('更新排行榜失敗', e);
            }
        }
    }).catch(function(e){ console.warn('saveTrialRecord 失敗：', e); });
}

// # 讀取秘境排行榜 Top N
async function loadTrialLeaderboardTopN(n) {
    if (!FIREBASE_ONLINE_ENABLED || !db) return [];
    var qs = await db.collection('leaderboard_trial_public').orderBy('bestScore','desc').limit(n||100).get();
    return qs.docs.map(function(d){ return Object.assign({id:d.id}, d.data()); });
}

// # 讀取秘境排行榜：取得各難度 Top 3 名（含玩家資訊）
async function loadTrialLeaderboardGrouped() {
    if (!FIREBASE_ONLINE_ENABLED || !db) return {};
    try {
        var qs = await db.collection('leaderboard_trial_public').get();
        var result = {};
        qs.docs.forEach(function(doc) {
            var d = doc.data() || {};
        // # 取得各難度最佳紀錄；兼容舊版屬性 bestByLevel
        var bestScores = d.bestScores || d.bestByLevel || {};
            // # 遍歷 1~10 難度
            for (var i = 1; i <= 10; i++) {
                var s = bestScores[i];
                if (typeof s === 'number' && s > 0) {
                    if (!result[i]) result[i] = [];
                    // # 將日期格式化（採用 createDate 或 updatedAt）
                    var dateStr = '';
                    var dt = d.updatedAt || d.createDate;
                    try {
                        if (dt && typeof dt.toDate === 'function') {
                            var dd = dt.toDate();
                            dateStr = dd.getFullYear() + '-' + String(dd.getMonth()+1).padStart(2,'0') + '-' + String(dd.getDate()).padStart(2,'0');
                        } else if (typeof dt === 'string') {
                            dateStr = dt.split('T')[0];
                        }
                    } catch (_) {}
                    result[i].push({
                        displayName: d.displayName || '無名修士',
                        gender: d.gender || '',
                        linggen: (typeof d.linggen !== 'undefined' && d.linggen !== null) ? d.linggen : '',
                        score: s,
                        date: dateStr
                    });
                }
            }
        });
        // # 排序並截取前 3 名
        Object.keys(result).forEach(function(k) {
            result[k].sort(function(a,b) {
                // # 按分數降序；若分數相同則日期近者在前
                if (b.score !== a.score) return b.score - a.score;
                if (a.date && b.date) {
                    return new Date(b.date) - new Date(a.date);
                }
                return 0;
            });
            result[k] = result[k].slice(0, 3);
        });
        return result;
    } catch (e) {
        console.warn('讀取排行榜分組失敗', e);
        return {};
    }
}

// # 顯示秘境排行榜（含離線資訊）
async function showTrialLeaderboard() {
    // 先嘗試重新讀取本地秘境紀錄，確保排行榜資料是最新的
    try {
        // 若 localStorage 可用，將本地紀錄載入 maxTrialScores；失敗時保持原值
        maxTrialScores = loadFromLocalStorage(TRIAL_SCORE_FILE, maxTrialScores || {});
    } catch (e) { /* ignore */ }

    // 如果雲端未啟用則顯示離線紀錄
    if (!FIREBASE_ONLINE_ENABLED || !db) {
        let content = '';
        if (Object.keys(maxTrialScores || {}).length > 0) {
            content += '<p>您的本地秘境最高紀錄：</p><ul style="padding-left:20px;">';
            for (let i = 1; i <= 10; i++) {
                const s = maxTrialScores[i] || 0;
                content += `<li>秘境難度 ${i}：${s} 題</li>`;
            }
            content += '</ul>';
        } else {
            content = '尚無本地秘境紀錄。';
        }
        showModal('秘境排行榜 (離線)', content, `<button data-action="close-modal">關閉</button>`);
        return;
    }
    let content = '';
    // # 從雲端讀取各難度前三名資料
    let grouped = {};
    try {
        grouped = await loadTrialLeaderboardGrouped();
    } catch (e) { console.warn(e); grouped = {}; }
    if (!grouped || Object.keys(grouped).length === 0) {
        // # 若雲端無資料，嘗試顯示本地紀錄
        if (maxTrialScores && Object.keys(maxTrialScores).length > 0) {
            content += '<p>您的本地秘境最高紀錄：</p><ul style="padding-left:20px;">';
            for (let i = 1; i <= 10; i++) {
                const s = maxTrialScores[i] || 0;
                content += `<li>秘境難度 ${i}：${s} 題</li>`;
            }
            content += '</ul>';
        } else {
            content = '目前暫無排行榜資料。';
        }
    } else {
        // # 建立每個難度的排行榜表格
        for (let i = 1; i <= 10; i++) {
            const entries = grouped[i] || [];
            content += `<h3 style="text-align:left; margin-top:10px;">難度 ${i}</h3>`;
            if (entries.length === 0) {
                content += '<p>暫無資料。</p>';
                continue;
            }
            content += '<table style="width:100%; text-align:center; border-collapse:collapse; margin-bottom:10px;">';
            content += '<tr><th style="border-bottom:1px solid #ccc;">名次</th><th style="border-bottom:1px solid #ccc;">姓名</th><th style="border-bottom:1px solid #ccc;">性別</th><th style="border-bottom:1px solid #ccc;">靈根</th><th style="border-bottom:1px solid #ccc;">最高答對題數</th><th style="border-bottom:1px solid #ccc;">上榜日期</th></tr>';
            entries.forEach(function(item, idx) {
                content += `<tr><td>${idx + 1}</td><td>${item.displayName || '無名修士'}</td><td>${item.gender || ''}</td><td>${(item.linggen === null || item.linggen === undefined || item.linggen === '') ? '' : item.linggen}</td><td>${item.score}</td><td>${item.date || ''}</td></tr>`;
            });
            content += '</table>';
        }
    }
    showModal('秘境排行榜', content, `<button data-action="close-modal">關閉</button>`);
}

// # 顯示登入/帳號管理介面
function showLoginMenu() {
    // 若雲端未啟用則顯示提示
    if (!ONLINE_ENABLED || !supabaseClient) {
        showModal('帳號', '雲端未啟用，無法登入。', `<button data-action="close-modal">關閉</button>`);
        return;
    }
    // 透過 ensureSignedIn() 取得目前使用者後再動態產生內容
    ensureSignedIn().then(function(user) {
        let content = '';
        if (user) {
            const meta = user.user_metadata || {};
            const name = meta.full_name || meta.displayName || user.email || '已登入';
            content += `<p>已登入為：${name}</p>`;
            content += `<button data-action="logout">登出</button>`;
        } else {
            // 尚未登入：提供登入選項。Supabase 不支援匿名登入。
            content += `<button data-action="login-google">以 Google 登入</button>`;
            content += `<button data-action="login-yahoo">以 Yahoo 登入</button>`;
            content += `<button data-action="login-facebook">以 Facebook 登入</button>`;
            content += `<button data-action="login-email">以 Email/密碼註冊登入</button>`;
        }
        showModal('登入 / 帳號', content, `<button data-action="close-modal">關閉</button>`);
    });
}


let { data, error } = await supabase.auth.signInWithOAuth({
  provider: 'github'
})

// # Google 登入
function loginGoogle() {
    if (!ONLINE_ENABLED || !supabaseClient) return;
    signInWithGoogleKeepData().then(function(){
        try { modal.style.display = 'none'; } catch (_) {}
        if (typeof renderMainMenu === 'function') renderMainMenu();
    }).catch(function(e){
        console.warn('Google 登入失敗', e);
        alert('Google 登入失敗');
    });
}

// # 匿名登入：手動呼叫 signInAnonymously（通常自動，但提供顯式操作）
function loginAnonymous() {
    // Supabase 不支援匿名登入
    alert('此平台不支援匿名登入，請使用其他方式登入');
}
// # Email/密碼 登入或註冊（簡易 prompt）
function loginEmail() {
    if (!ONLINE_ENABLED || !supabaseClient) return;
    const email = prompt('請輸入 Email');
    if (!email) return;
    const password = prompt('請輸入密碼 (至少 6 字)');
    if (!password) return;
    upgradeToEmailPassword(email, password).then(function(){
        try { modal.style.display = 'none'; } catch (_) {}
        if (typeof renderMainMenu === 'function') renderMainMenu();
    }).catch(function(e){
        console.warn('Email 登入或註冊失敗', e);
        alert('Email 登入或註冊失敗');
    });
}

// # Yahoo 登入
function loginYahoo() {
    if (!ONLINE_ENABLED || !supabaseClient) return;
    signInWithYahooKeepData().then(function(){
        try { modal.style.display = 'none'; } catch (_) {}
        if (typeof renderMainMenu === 'function') renderMainMenu();
    }).catch(function(e){
        console.warn('Yahoo 登入失敗', e);
        alert('Yahoo 登入失敗');
    });
}

// # Facebook 登入
function loginFacebook() {
    if (!ONLINE_ENABLED || !supabaseClient) return;
    signInWithFacebookKeepData().then(function(){
        try { modal.style.display = 'none'; } catch (_) {}
        if (typeof renderMainMenu === 'function') renderMainMenu();
    }).catch(function(e){
        console.warn('Facebook 登入失敗', e);
        alert('Facebook 登入失敗');
    });
}

// # 登出
function logout() {
    if (!ONLINE_ENABLED || !supabaseClient) return;
    signOutOnline().then(function(){
        try { modal.style.display = 'none'; } catch (_) {}
        if (typeof renderMainMenu === 'function') renderMainMenu();
    }).catch(function(e){
        console.warn('登出失敗', e);
        alert('登出失敗');
    });
}

// 更新主選單資料，例如修煉經驗、靈石與訓練次數等。
// # 當消耗或增加修煉經驗/靈石後，可調用此函式即時更新主選單顯示。
function updateMainMenuInfo() {
    const info = document.querySelector('.info-section');
    if (!info) return;
    const highestScore = Object.keys(maxScores).length > 0 ? Math.max(...Object.values(maxScores)) : 0;
    const currentStage = getCultivationStage(gameState.exp);
    const nextInfo = getNextCultivationInfo(gameState.exp);
    const ps = info.querySelectorAll('p');
    if (ps[0]) ps[0].innerHTML = `🧘‍♂️ 目前修為：${currentStage}`;
    if (ps[1]) ps[1].innerHTML = `🎖️ 目前仙門位階：${gameState.current_title}`;
    let tip = "🌟 你已達到最終修為！";
    let progressVal = 100;
    if (nextInfo) {
        tip = `⬆️ 距離「${nextInfo.next_stage}」還差 ${nextInfo.exp_needed} 修煉經驗、訓練 ${nextInfo.train_needed} 次`;
        let prevNeed = 0;
        for (const [need_exp] of CULTIVATION_STAGES) {
            if (gameState.exp >= need_exp) prevNeed = need_exp;
            else break;
        }
        let nextNeed = CULTIVATION_STAGES.find(([need_exp]) => gameState.exp < need_exp)?.[0];
        if (nextNeed !== undefined) {
            const span = Math.max(1, nextNeed - prevNeed);
            progressVal = Math.floor((gameState.exp - prevNeed) * 100 / span);
        }
    }
    if (ps[2]) ps[2].innerHTML = tip;
    const progressEl = info.querySelector('progress');
    if (progressEl) progressEl.value = progressVal;
    if (ps[3]) ps[3].innerHTML = `🏋️ 累積訓練次數：${gameState.total} | ⚔️ 修煉經驗：${gameState.exp} | ⭐ 最高分：${highestScore}`;
    if (ps[4]) ps[4].innerHTML = `🎟️ 測試機會：${gameState.luck_tickets} 次 (累積獲得：${gameState.luck_tickets_total})`;
    if (ps[5]) ps[5].innerHTML = `💎 靈石：${gameState.stones}`;
    // # 更新個人資訊與靈根
    if (ps[6]) {
        const nameVal = gameState.personalName || '未設定';
        const genderVal = gameState.gender || '未設定';
        let ling = '';
        if (gameState.linggen === undefined || gameState.linggen === null) {
            ling = '未測';
        } else if (gameState.linggen <= 0) {
            ling = '無靈根';
        } else {
            ling = gameState.linggen + ' 靈根';
        }
        ps[6].innerHTML = `👤 姓名：${nameVal} | 性別：${genderVal} | 🌱 靈根：${ling}`;
    }
}

function showBackpack() {
    const sortedInventory = Object.entries(gameState.inventory)
      .filter(([, qty]) => qty > 0)
      // 使用 compareItemNames 確保依類型與品階排序
      .sort(([a], [b]) => compareItemNames(a, b));
    let content = '';
    if (sortedInventory.length === 0) {
      content = "<p>背包空空如也</p>";
    } else {
      content = '<ul style="padding-left: 20px;">' +
        sortedInventory.map(([name, qty]) => `<li>${name} ×${qty}</li>`).join('') +
        '</ul>';
    }
    const footer = `
      <button data-action="use-exp-items">🍵 使用仙丹</button>
      <button class="btn-danger" data-action="delete-items">🗑️ 刪除道具</button>`;
    showModal("🎒 背包", content, footer);
}

// === 使用仙丹（EXP 類）===
function showUseExpDialog() {
  const expItems = Object.entries(gameState.inventory)
    .filter(([name, qty]) => qty > 0 && (ITEM_EFFECTS[name]?.type === 'exp'))
    // 依類型與品階排序
    .sort(([a], [b]) => compareItemNames(a, b));
  let content = '';
  if (expItems.length === 0) {
    content = "<p>沒有可用的仙丹類道具</p>";
  } else {
    content = expItems.map(([name, qty]) => {
      const eff = ITEM_EFFECTS[name] || {};
      const addExp = eff.n || 0;
      return `
        <div class="modal-item-row">
          <label for="useexp-${name}">${name}（持有 ${qty}）→ 每顆 +${addExp} EXP</label>
          <input type="number" id="useexp-${name}" min="0" max="${qty}" value="0" />
        </div>`;
    }).join('');
  }
  const footer = `
    <button data-action="fill-all-exp">全部填滿</button>
    <button data-action="confirm-use-exp">確認使用</button>
    <button data-action="confirm-use-exp-all" class="btn-warning">全部使用</button>`;
  showModal("🍵 使用仙丹", content, footer);
}

function confirmUseExp() {
  const inputs = modalBody.querySelectorAll('input[type="number"]');
  let totalGain = 0;
  const inv = gameState.inventory;
  inputs.forEach(input => {
    const qty = Math.max(0, parseInt(input.value || '0', 10));
    if (!qty) return;
    const name = input.id.replace('useexp-', '');
    const eff = ITEM_EFFECTS[name] || {};
    const add = (eff.n || 0) * qty;
    const cur = inv[name] || 0;
    inv[name] = Math.max(0, cur - qty);
    totalGain += add;
  });
  if (totalGain > 0) {
    const prevExp = gameState.exp;
    gameState.exp += totalGain;
    saveGameState();
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    showModal("🍵 使用結果",
      `<p>共獲得 +${totalGain} EXP</p>${levelupMsg ? `<p class="msg-levelup">${levelupMsg}</p>` : ''}`,
      `<button data-action="close-modal">關閉</button>`);
  } else {
    showModal("🍵 使用結果", "<p>未選擇任何仙丹。</p>", `<button data-action="close-modal">關閉</button>`);
  }
}

// === 批量填滿與全部使用 EXP 類仙丹 ===
function fillAllExpInputs() {
  const inputs = modalBody.querySelectorAll('input[id^="useexp-"]');
  inputs.forEach(input => {
    const max = parseInt(input.getAttribute('max') || '0', 10);
    if (max > 0) input.value = String(max);
  });
}

function confirmUseExpAll() {
  const inv = gameState.inventory;
  let totalGain = 0;
  Object.entries(inv).forEach(([name, qty]) => {
    if (qty > 0 && (ITEM_EFFECTS[name]?.type === 'exp')) {
      const eff = ITEM_EFFECTS[name];
      const add = (eff.n || 0) * qty;
      inv[name] = 0;
      totalGain += add;
    }
  });
  if (totalGain > 0) {
    const prevExp = gameState.exp;
    gameState.exp += totalGain;
    saveGameState();
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    showModal("🍵 使用結果",
      `<p>共獲得 +${totalGain} EXP（全部使用）</p>${levelupMsg ? `<p class="msg-levelup">${levelupMsg}</p>` : ''}`,
      `<button data-action="close-modal">關閉</button>`);
  } else {
    showModal("🍵 使用結果", "<p>沒有可用的仙丹。</p>", `<button data-action="close-modal">關閉</button>`);
  }
}

// === 刪除道具 ===
function showDeleteItemsDialog() {
  const deletables = Object.entries(gameState.inventory)
    .filter(([, qty]) => qty > 0)
    // 依類型與品階排序
    .sort(([a], [b]) => compareItemNames(a, b));
  let content = '';
  if (deletables.length === 0) {
    content = "<p>背包沒有可以刪除的道具</p>";
  } else {
    content = deletables.map(([name, qty]) => `
      <div class="modal-item-row">
        <label for="del-${name}">${name}（持有 ${qty}）</label>
        <input type="number" id="del-${name}" min="0" max="${qty}" value="0" />
      </div>`).join('');
  }
  const footer = `<button data-action="confirm-delete-items">確認刪除</button>`;
  showModal("🗑️ 刪除道具", content, footer);
}

function confirmDeleteItems() {
  const inputs = modalBody.querySelectorAll('input[type="number"]');
  const inv = gameState.inventory;
  let removedList = [];
  inputs.forEach(input => {
    const qty = Math.max(0, parseInt(input.value || '0', 10));
    if (!qty) return;
    const name = input.id.replace('del-', '');
    const cur = inv[name] || 0;
    const rm = Math.min(qty, cur);
    if (rm > 0) {
      inv[name] = cur - rm;
      removedList.push(`${name} ×${rm}`);
    }
  });
  saveGameState();
  showModal("🗑️ 刪除結果",
    removedList.length ? `<p>已刪除：${removedList.join('、')}</p>` : "<p>未刪除任何道具</p>",
    `<button data-action="close-modal">關閉</button>`);
}

function showShop() {
    const sortedItems = Object.entries(ITEM_STONE_PRICES).sort(([a], [b]) => {
        const keyA = getItemSortKey(a);
        const keyB = getItemSortKey(b);
        if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
        if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
        return a.localeCompare(b, 'zh-Hant');
    });

    let content = `<p style="text-align:center;"><b>當前靈石：${gameState.stones}</b></p>`;
    content += sortedItems.map(([item, cost]) => {
        const desc = ITEM_EFFECTS[item]?.desc || '';
        return `<div class="modal-item-row">
            <label for="shop-${item}">${item} - ${cost} 靈石 (${desc})</label>
            <input type="number" id="shop-${item}" min="0" value="0" placeholder="0">
        </div>`;
    }).join('');

    let footer = `<button data-action="bulk-buy-items">購買選擇</button>
                  <button class="btn-warning" data-action="show-sell-dialog">販賣道具</button>
                  <button class="btn-secondary" data-action="show-upgrade-dialog">品階升級</button>`;
    
    showModal("🛒 商店", content, footer);
}

function bulkBuyItems() {
    const inputs = modalBody.querySelectorAll('input[type="number"]');
    let totalCost = 0;
    const purchase = {};

    inputs.forEach(input => {
        const qty = parseInt(input.value, 10);
        if (qty > 0) {
            const itemName = input.id.replace('shop-', '');
            const price = ITEM_STONE_PRICES[itemName] || 0;
            totalCost += price * qty;
            purchase[itemName] = qty;
        }
    });

    if (totalCost > gameState.stones) {
        alert(`靈石不足！需要 ${totalCost}，您只有 ${gameState.stones}。`);
        return;
    }

    if (Object.keys(purchase).length > 0) {
        gameState.stones -= totalCost;
        Object.entries(purchase).forEach(([item, qty]) => {
            gameState.inventory[item] = (gameState.inventory[item] || 0) + qty;
            if (!gameState.inventory_order.includes(item)) {
                gameState.inventory_order.push(item);
                 gameState.inventory_order.sort((a, b) => compareItemNames(a, b));
            }
        });
        saveGameState();
        addTemporaryMessage(`✅ 購買成功，花費 ${totalCost} 靈石！`, 'msg-shop');
    }
    modal.style.display = "none";
    renderMainMenu();
}

function showUpgradeDialog() {
    const upgradable = Object.keys(UPGRADE_PATHS)
        .filter(item => (gameState.inventory[item] || 0) > 0 && !(gameState.inventory[UPGRADE_PATHS[item]] > 0))
        // 依類型與品階排序
        .sort((a,b) => compareItemNames(a, b));

    let content = `<p style="text-align:center;"><b>當前靈石：${gameState.stones}</b></p>`;
    if (upgradable.length === 0) {
        content += `<p>沒有可升級的道具。</p>`;
    } else {
        content += upgradable.map(item => {
            const nextItem = UPGRADE_PATHS[item];
            const cost = ITEM_EFFECTS[item].upgrade_cost || 0;
            return `<div class="modal-item-row">
                <span>升級 ${item} → ${nextItem}</span>
                <button data-action="upgrade-item" data-current="${item}" data-next="${nextItem}" data-cost="${cost}" ${gameState.stones < cost ? 'disabled' : ''}>${cost} 靈石</button>
            </div>`;
        }).join('');
    }
    showModal("✨ 品階升級", content, `<button data-action="show-shop">返回商店</button>`);
}

function upgradeItem(currentItem, nextItem, cost) {
    if (gameState.stones < cost) {
        alert("靈石不足！");
        return;
    }
    gameState.stones -= cost;
    gameState.inventory[nextItem] = (gameState.inventory[nextItem] || 0) + 1;
    // Don't remove old item
    if (!gameState.inventory_order.includes(nextItem)) {
        gameState.inventory_order.push(nextItem);
        gameState.inventory_order.sort((a,b) => compareItemNames(a,b));
    }
    saveGameState();
    // 扣靈石後立即更新主畫面資訊（尤其是靈石顯示）
    if (typeof updateMainMenuInfo === 'function') {
        updateMainMenuInfo();
    }
    alert(`升級成功！獲得 ${nextItem}`);
    showUpgradeDialog(); // Refresh modal
}

// ===================== 遊戲中道具使用 =====================

function showUseItemDialog() {
    const usableItems = Object.entries(gameState.inventory)
      .filter(([, qty]) => qty > 0)
      .map(([name]) => name)
      .filter(name => {
        const type = ITEM_EFFECTS[name]?.type;
        return ["correct", "wrong", "multi_choice", "reveal_wrong", "add_time"].includes(type);
      })
      // 依類型與品階排序
      .sort((a, b) => compareItemNames(a, b));
    let content = '';
    if (usableItems.length === 0) {
      content = '<p>沒有可用的戰鬥道具</p>';
    } else {
      content = usableItems.map(item => {
        const eff = ITEM_EFFECTS[item];
        const cost = eff.exp_cost || 0;
        let disabled = '';
        let tooltip = '';
        if (gameState.exp < cost) {
          disabled = 'disabled';
          tooltip = ` (修煉經驗不足: ${cost})`;
        }
        if (['correct', 'wrong', 'multi_choice'].includes(eff.type) && trainingState.hasUsedSingleUseItem) {
          disabled = 'disabled';
          tooltip = ' (本題已用過此類道具)';
        }
        if (['correct', 'wrong'].includes(eff.type)) {
          const allowedGrade = getGradeByDifficulty(trainingState.difficulty);
          if (!item.startsWith(allowedGrade)) {
            disabled = 'disabled';
            tooltip = ` (此難度需用 ${allowedGrade} 道具)`;
          }
        }
        return `<button data-action="use-item" data-item-name="${item}" ${disabled}>
          ${item} ×${gameState.inventory[item]}
          <br><small>${eff.desc || ''}${cost > 0 ? ` (消耗${cost} EXP)` : ''}${tooltip}</small>
        </button>`;
      }).join('');
    }
    showModal('🎒 使用道具', content);
}

function useItem(itemName) {
    const eff  = ITEM_EFFECTS[itemName];
    if (!eff) return;
    const cost = eff.exp_cost || 0;
    if (gameState.exp < cost) return;
    if (['correct', 'wrong', 'multi_choice'].includes(eff.type)) {
      if (trainingState.hasUsedSingleUseItem) return;
      trainingState.hasUsedSingleUseItem = true;
    }
    gameState.exp -= cost;
    if (['correct', 'wrong'].includes(eff.type)) {
      gameState.inventory[itemName] = Math.max(0, (gameState.inventory[itemName] || 0) - 1);
    }
    saveGameState();
    // # 線上版新增：記錄本局使用過的道具名稱（去重由前端/雲端自行處理）
    try {
        if (typeof trainingState !== 'undefined') {
            trainingState.usedItems = trainingState.usedItems || [];
            if (!trainingState.usedItems.includes(itemName)) {
                trainingState.usedItems.push(itemName);
            }
        }
    } catch (e) { /* # ignore */ }

    const fb = document.getElementById('feedback-label');
    let msg = '';
    if (eff.type === 'multi_choice') {
      trainingState.allowedChoices += (eff.n || 1);
      enterMultiChoiceMode();
      msg = `⚔️ 兵器效果：本題可選答案數增加 ${eff.n}（總共 ${trainingState.allowedChoices} 次）`;
    } else if (eff.type === 'reveal_wrong') {
      const buttons = trainingState.gameGridButtons || [];
      let remain = eff.n || 1;
      for (const b of buttons) {
        if (remain <= 0) break;
        const choice = b.dataset.choice;
        if (!trainingState.correctAnswers.includes(choice) && !b.classList.contains('hint-wrong')) {
          b.classList.add('hint-wrong');
          remain--;
        }
      }
      msg = `📜 功法效果：已標示 ${eff.n} 個錯誤答案`;
    } else if (eff.type === 'add_time') {
      // 陣法增加作答時間僅限本題有效：中途可以疊加並即時生效
      const inc = eff.n || 0;
      trainingState.roundExtraTime = (trainingState.roundExtraTime || 0) + inc;
      // 若倒數正在跑，立即增加剩餘秒數
      if (typeof trainingState.countdownRemaining === 'number') {
        trainingState.countdownRemaining += inc;
        const label = document.getElementById('countdown-label');
        if (label && trainingState.countdownRemaining >= 0) {
          label.textContent = `作答倒數：${trainingState.countdownRemaining} 秒`;
        }
      }
      msg = `⛩️ 陣法效果：作答時間增加 ${inc} 秒（僅本題）`;
    } else if (eff.type === 'correct') {
// 靈器：顯示正確答案。n <= 0 視為全部，否則顯示 n 個
const buttons = trainingState.gameGridButtons || [];
// 找出所有尚未標示的正確按鈕
const correctButtons = buttons.filter(b =>
  trainingState.correctAnswers.includes(b.dataset.choice) && !b.classList.contains('hint-correct')
);
let toReveal;
if (eff.n <= 0) {
  // n <= 0 表示全部亮顯
  toReveal = correctButtons;
} else {
  // 否則只顯示前 n 個
  toReveal = correctButtons.slice(0, eff.n);
}
// 將選中的按鈕標記為正確
toReveal.forEach(b => b.classList.add('hint-correct'));
msg = `🪬 靈器效果：已標示 ${eff.n <= 0 ? '全部' : toReveal.length} 個正確答案`;
    } else if (eff.type === 'wrong') {
      const buttons = trainingState.gameGridButtons || [];
      let remain = eff.n || 1;
      for (const b of buttons) {
        if (remain <= 0) break;
        const choice = b.dataset.choice;
        if (!trainingState.correctAnswers.includes(choice) && !b.classList.contains('hint-wrong')) {
          b.classList.add('hint-wrong');
          remain--;
        }
      }
      msg = `🧿 靈符效果：已排除 ${eff.n} 個錯誤答案`;
    }
    if (fb) { fb.textContent = msg; fb.className = "feedback info"; }
    modal.style.display = 'none';
}

// Stubs for unimplemented modal functions
function useExpItems() { showUseExpDialog(); }
function deleteItems() { showDeleteItemsDialog(); }
function showSellDialog() {
  const sellable = Object.entries(gameState.inventory)
    .filter(([name, qty]) => qty > 0 && ITEM_STONE_PRICES[name] !== undefined)
    // 依類型與品階排序
    .sort(([a], [b]) => compareItemNames(a, b));
  let content = '';
  if (sellable.length === 0) {
    content = '<p>背包中沒有可販賣的道具。</p>';
  } else {
    content = sellable.map(([name, qty]) => {
      const sellPriceSingle = Math.floor((ITEM_STONE_PRICES[name] || 0) / 2);
      return `
        <div class="modal-item-row">
          <label for="sell-${name}">${name}（持有 ${qty}） - 賣價: ${sellPriceSingle} 靈石/個</label>
          <input type="number" id="sell-${name}" min="0" max="${qty}" value="0" />
        </div>`;
    }).join('');
    content += `<p id="sell-total" style="margin-top:10px;text-align:center;">預計可獲得：0 靈石</p>`;
  }
  const footer = `<button data-action="confirm-sell-items">確認販賣</button>`;
  showModal("💰 販賣道具", content, footer);
  // attach update for predicted sell value
  setTimeout(() => {
    const totalLabel = document.getElementById('sell-total');
    function updateTotal() {
      let totalBuyValue = 0;
      sellable.forEach(([name]) => {
        const input = modalBody.querySelector(`#sell-${name}`);
        if (input) {
          const count = parseInt(input.value || '0', 10);
          if (count > 0) {
            const price = ITEM_STONE_PRICES[name] || 0;
            totalBuyValue += price * count;
          }
        }
      });
      const sellValue = Math.floor(totalBuyValue / 2);
      if (totalLabel) {
        totalLabel.textContent = `預計可獲得：${sellValue} 靈石`;
      }
    }
    sellable.forEach(([name]) => {
      const input = modalBody.querySelector(`#sell-${name}`);
      if (input) {
        input.addEventListener('input', updateTotal);
        input.addEventListener('change', updateTotal);
      }
    });
    updateTotal();
  }, 0);
}

function confirmSellItems() {
  const toSell = [];
  let totalBuyValue = 0;
  Object.entries(gameState.inventory).forEach(([name, qty]) => {
    const input = modalBody.querySelector(`#sell-${name}`);
    if (input) {
      const count = Math.max(0, parseInt(input.value || '0', 10));
      if (count > 0) {
        toSell.push({name: name, qty: count});
        totalBuyValue += (ITEM_STONE_PRICES[name] || 0) * count;
      }
    }
  });
  if (toSell.length === 0) {
    showModal("💰 販賣結果", "<p>未販賣任何道具</p>", `<button data-action="close-modal">關閉</button>`);
    return;
  }
  const sellValue = Math.floor(totalBuyValue / 2);
  toSell.forEach(item => {
    gameState.inventory[item.name] = Math.max(0, (gameState.inventory[item.name] || 0) - item.qty);
  });
  gameState.stones += sellValue;
  saveGameState();
  const soldItemsDesc = toSell.map(item => `${item.name} ×${item.qty}`);
  showModal("💰 販賣結果", `<p>已販賣：${soldItemsDesc.join('、')}</p><p>獲得 ${sellValue} 靈石</p>`, `<button data-action="close-modal">關閉</button>`);
}


// ===================== 全域事件處理 =====================
document.body.addEventListener('click', (event) => {
    let target = event.target;
    // If the target itself doesn't have the action, check its parent
    if (!target.dataset.action) {
        target = target.closest('[data-action]');
    }
    if (!target) return;

    const action = target.dataset.action;
    
    const simpleActions = {
        'render-main-menu': renderMainMenu, 'render-test-luck-menu': renderTestLuckMenu,
        'show-stage-list': showStageList, 'show-rank-list': showRankList,
        'show-backpack': showBackpack, 'show-shop': showShop,
        'reset-stats': resetTrainingStats, 'clear-scores': clearMaxScores,
        'run-today-luck': runTodayLuck, 'show-luck-history': showLuckHistory,
        'show-upgrade-dialog': showUpgradeDialog, 'check-answer-multi': checkAnswerMulti,
        'show-use-item-dialog': showUseItemDialog, 'close-modal': () => modal.style.display = "none",
        'bulk-buy-items': bulkBuyItems,
        'use-exp-items': showUseExpDialog,
        'delete-items': showDeleteItemsDialog,
        'confirm-use-exp': confirmUseExp,
        'confirm-delete-items': confirmDeleteItems,
        'fill-all-exp': fillAllExpInputs,
        'confirm-use-exp-all': confirmUseExpAll,
        'confirm-sell-items': confirmSellItems,
        'show-sell-dialog': showSellDialog,
        'show-game-rules': showGameRules,
        'test-sfx': () => {
            try {
                if (typeof ensureAudio === 'function' && typeof playBeep === 'function') {
                    ensureAudio();
                    playBeep({ freq: 880 });
                }
            } catch (e) {}
        },
        // # 新增簡易動作：秘境試煉選單、秘境排行榜、登入介面與登入登出
        'render-secret-trial-menu': renderSecretTrialMenu,
        'show-trial-leaderboard': showTrialLeaderboard,
        'show-login-menu': showLoginMenu,
        'login-google': loginGoogle,
        'login-email': loginEmail,
        'login-yahoo': loginYahoo,
        'login-facebook': loginFacebook,
        'logout': logout,
        'login-anonymous': loginAnonymous,
        // # 開始靈根測試：於初始化階段點擊按鈕
        'start-linggen-test': startLinggenTest,
        // # 新增再次挑戰動作：重新開始上一場訓練或秘境試煉
        'retry-training': () => {
            try {
                if (typeof startTraining === 'function' && trainingState && trainingState.difficulty) {
                    startTraining(trainingState.difficulty);
                }
            } catch (e) { console.warn('無法再次挑戰訓練', e); }
        },
        'retry-trial': () => {
            try {
                if (typeof startTrial === 'function' && trainingState && trainingState.difficulty) {
                    startTrial(trainingState.difficulty);
                }
            } catch (e) { console.warn('無法再次挑戰秘境', e); }
        },
    };

    if (simpleActions[action]) {
        simpleActions[action]();
        return;
    }

    // Actions with parameters
    switch(action) {
        case 'start-training':
            startTraining(parseInt(target.dataset.level, 10));
            break;
        case 'exchange-stones':
            exchangeStones(parseInt(target.dataset.count, 10));
            break;
        case 'redeem-tickets':
            redeemTickets(parseInt(target.dataset.pieces, 10), parseInt(target.dataset.cost, 10));
            break;
        case 'run-luck-draw':
            runLuckDraw(parseInt(target.dataset.draws, 10), target.dataset.mode);
            break;
        case 'upgrade-item':
            upgradeItem(target.dataset.current, target.dataset.next, parseInt(target.dataset.cost, 10));
            break;
        case 'use-item':
            useItem(target.dataset.itemName);
            break;
        case 'grid-btn': 
            onGridButtonClick(target);
            break;
        case 'start-trial':
            startTrial(parseInt(target.dataset.level, 10));
            break;
    }
});


// ===================== 啟動遊戲 =====================
loadGameState();
renderMainMenu();

}); // ▲▲▲ End of DOMContentLoaded listener ▲▲▲
</script>

<!-- 音效與箭頭後援程式：在行動裝置上顯示箭頭，並生成音效（無需外部音檔） -->
<script>
// ==== 行動裝置箭頭 SVG 後援 ====
function svgArrow(dir, size = 18) {
    const pathMap = {
        up:   'M9 2 L16 14 H2 Z',
        right:'M2 2 L14 9 L2 16 Z',
        down: 'M2 2 L16 2 L9 16 Z',
        left: 'M2 9 L14 2 L14 16 Z'
    };
    const key = pathMap[dir] ? dir : 'up';
    const svg = `<svg viewBox="0 0 18 18" width="${size}" height="${size}" aria-hidden="true" style="display:inline-block;vertical-align:middle"><path d="${pathMap[key]}" fill="currentColor"/></svg>`;
    const el = document.createElement('span');
    el.className = 'luck-arrow-svg';
    el.innerHTML = svg;
    return el;
}

// 將含有箭頭字元或指定 data 屬性的節點替換為 SVG
function patchLuckArrows() {
    const selector = '.luck-arrow, [data-luck-arrow], [data-dir]';
    document.querySelectorAll(selector).forEach(node => {
        // 已經有 SVG 就不重複替換
        if (node.querySelector('svg')) return;
        // 判斷方向
        let dir = node.dataset.luckArrow || node.dataset.dir || '';
        // 若未指定，根據內容判斷
        if (!dir) {
            const text = node.textContent.trim();
            const map = {'↑': 'up', '→': 'right', '↓': 'down', '←': 'left'};
            dir = map[text] || 'up';
        }
        // 清空文字並插入 SVG
        node.textContent = '';
        node.appendChild(svgArrow(dir));
    });
}

// ==== WebAudio 音效工具 ====
let __audioCtx = null;
function ensureAudio() {
    if (!__audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        __audioCtx = new Ctx();
    }
    return __audioCtx;
}

function playBeep(opts) {
    const cfg = Object.assign({ freq: 880, dur: 0.12, type: 'sine', gain: 0.06 }, opts);
    const ctx = ensureAudio();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gainNode = ctx.createGain();
    osc.type = cfg.type;
    osc.frequency.value = cfg.freq;
    gainNode.gain.value = cfg.gain;
    osc.connect(gainNode).connect(ctx.destination);
    const t = ctx.currentTime;
    osc.start(t);
    osc.stop(t + cfg.dur);
}

function playLevelUp() {
    const ctx = ensureAudio();
    if (!ctx) return;
    const now = ctx.currentTime;
    // 上行小和弦：C-E-G 依序響起
    [[523.25, 0], [659.25, 0.08], [783.99, 0.16]].forEach(([freq, offset]) => {
        const osc = ctx.createOscillator();
        const gainNode = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        gainNode.gain.value = 0.05;
        osc.connect(gainNode).connect(ctx.destination);
        osc.start(now + offset);
        osc.stop(now + offset + 0.18);
    });
}

// ==== 獎勵音效：模擬樂透中獎音效，播放一連串漸高的 beep 音 ====
function playRewardSound() {
    try {
        // 確保音效系統初始化
        ensureAudio();
        // 連續播放三個頻率的 beep，形成簡單的中獎音效
        playBeep({ freq: 880, dur: 0.14, type: 'square', gain: 0.08 });
        setTimeout(() => playBeep({ freq: 1046.5, dur: 0.14, type: 'square', gain: 0.07 }), 160);
        setTimeout(() => playBeep({ freq: 1318.5, dur: 0.14, type: 'square', gain: 0.06 }), 320);
    } catch (e) {
        console.warn('playRewardSound failed', e);
    }
}

// ==== 初始化與事件綁定 ====
window.addEventListener('DOMContentLoaded', () => {
    try {
        patchLuckArrows();
    } catch (e) {}
});
</script>


<!-- ==================== 線上版整合：Firebase（Auth + Firestore + 離線） ==================== -->
<!-- # 若未填入你的 firebaseConfig，雲端功能不會啟用；不影響離線本地功能 -->
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
<script>
// # Firebase 初始化（請把 YOUR_* 換成你的專案設定）
var FIREBASE_ONLINE_ENABLED = true;  // # 若要暫時關閉雲端，可設為 false
// # 將以下設定改為您在 Firebase Console 建立專案後取得的實際值。
// # 如果您是依照官方指引使用 npm 或 <script> 標籤載入 Firebase，
// # 建議保持此處格式一致即可啟用雲端功能。
var firebaseConfig = {
  apiKey: "AIzaSyBu3lcaLChWhzGmIPWE5CsZOIugPbhEg58",           // # 專案的 API Key
  authDomain: "xiuxian-luck-trainer.firebaseapp.com",           // # 專案授權網域
  projectId: "xiuxian-luck-trainer",                           // # 專案 ID
  storageBucket: "xiuxian-luck-trainer.firebasestorage.app",    // # (可選) 儲存空間桶名稱
  messagingSenderId: "185296094422",                           // # (可選) Cloud Messaging 發送者 ID
  appId: "1:185296094422:web:b86866eb98842e52e97577",          // # (可選) 應用程式 ID
  measurementId: "G-QTDH5X3CMT"                               // # (可選) Google Analytics 量測 ID
};
try {
  if (FIREBASE_ONLINE_ENABLED) { firebase.initializeApp(firebaseConfig); }
} catch (e) { console.warn('Firebase init failed (可能是未填 config)：', e); FIREBASE_ONLINE_ENABLED = false; }

// # Firestore & 離線快取
var db = null;
try {
  if (FIREBASE_ONLINE_ENABLED) {
    db = firebase.firestore();
    db.enablePersistence({ synchronizeTabs: true }).catch(function(){ /* # 無痕模式或衝突 */ });
  }
} catch (e) { console.warn('Firestore init failed：', e); FIREBASE_ONLINE_ENABLED = false; }

// # Auth（匿名自動登入；之後可升級 Google/Email 並保留紀錄）
var auth = null;
try { if (FIREBASE_ONLINE_ENABLED) { auth = firebase.auth(); } } catch (e) {}

function ensureSignedIn() {
  return new Promise(function (resolve) {
    if (!FIREBASE_ONLINE_ENABLED || !auth) return resolve(null);

    var off = auth.onAuthStateChanged(async function (u) {
      if (u) { off(); return resolve(u); }

      try {
        var cred = await auth.signInAnonymously();  // # 匿名登入
        off();
        return resolve(cred.user);
      } catch (e) {
        off();
        console.warn('匿名登入失敗（改為離線模式）：', e);
        FIREBASE_ONLINE_ENABLED = false;

        var code = (e && e.code) || '';
        var host = (location && location.hostname) ? location.hostname : '';
        var msg = '雲端連線未啟用，已切換為本機模式。';

        if (code === 'auth/unauthorized-domain') {
          msg = '目前網域未加入 Firebase 授權網域。請到 Firebase Console > Authentication > Settings > Authorized domains，加入：' + host;
        } else if (code === 'auth/operation-not-allowed') {
          msg = '匿名登入尚未啟用。請到 Firebase Console > Authentication > Sign-in method，開啟「匿名」。';
        } else if (code === 'auth/network-request-failed') {
          msg = '網路請求失敗，可能被瀏覽器阻擋第三方 Cookie 或網路中斷。';
        }

        // # 建立右下角離線提示
        try {
          var badge = document.getElementById('onlineStatusBadge');
          if (!badge) {
            badge = document.createElement('div');
            badge.id = 'onlineStatusBadge';
            badge.style.cssText = 'position:fixed;right:8px;bottom:8px;background:#222;color:#fff;padding:8px 10px;border-radius:8px;font-size:12px;opacity:.9;z-index:10000;';
            document.body.appendChild(badge);
          }
          badge.textContent = '雲端：離線（' + host + '）';
          badge.title = msg;
        } catch (_) {}

        return resolve(null);
      }
    });
  });
}

// # 升級登入（Google）保留匿名資料
async function signInWithGoogleKeepData() {
  if (!ONLINE_ENABLED || !supabaseClient) return null;
  try {
    const { data, error } = await supabaseClient.auth.signInWithOAuth({
      provider: 'google',
      options: { redirectTo: window.location.href }
    });
    if (error) { throw error; }
    return data && data.user ? data.user : null;
  } catch (e) {
    console.warn('Google 登入失敗', e);
    throw e;
  }
}

// # 升級登入（Yahoo）保留匿名資料
async function signInWithYahooKeepData() {
  if (!ONLINE_ENABLED || !supabaseClient) return null;
  try {
    const { data, error } = await supabaseClient.auth.signInWithOAuth({
      provider: 'yahoo',
      options: { redirectTo: window.location.href }
    });
    if (error) { throw error; }
    return data && data.user ? data.user : null;
  } catch (e) {
    console.warn('Yahoo 登入失敗', e);
    throw e;
  }
}

// # 升級登入（Facebook）保留匿名資料
async function signInWithFacebookKeepData() {
  if (!ONLINE_ENABLED || !supabaseClient) return null;
  try {
    const { data, error } = await supabaseClient.auth.signInWithOAuth({
      provider: 'facebook',
      options: { redirectTo: window.location.href }
    });
    if (error) { throw error; }
    return data && data.user ? data.user : null;
  } catch (e) {
    console.warn('Facebook 登入失敗', e);
    throw e;
  }
}

// # 升級登入（Email/Password）保留匿名資料
async function upgradeToEmailPassword(email, password) {
  // Email/密碼註冊或登入（Supabase）
  if (!ONLINE_ENABLED || !supabaseClient) return null;
  try {
    // 嘗試以密碼登入，若失敗則註冊新帳號
    let { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
    if (error) {
      let { data: signUpData, error: signUpError } = await supabaseClient.auth.signUp({ email, password });
      if (signUpError) { console.warn('註冊失敗：', signUpError); return null; }
      return signUpData.user;
    }
    return data.user;
  } catch (e) {
    console.warn('Email/密碼登入失敗', e);
    return null;
  }
}

function signOutOnline() {
  // 登出 Supabase
  if (supabaseClient) {
    return supabaseClient.auth.signOut();
  }
}

// # 雲端資料模型與寫入
async function saveRunRecord(rec) {
  // # rec: { level, score, mode, usedItems, durationSec, result, publishToLeaderboard }
  if (!FIREBASE_ONLINE_ENABLED || !db) return; // # 未啟用則略過
  var u = auth && auth.currentUser ? auth.currentUser : await ensureSignedIn();
  if (!u) return; // # 無法登入則略過
  var uid = u.uid;
  var now = firebase.firestore.Timestamp.now();
  var runRef = db.collection('users').doc(uid).collection('runs').doc(); // # 自動 runId
  var statRef = db.collection('user_stats').doc(uid);

  return db.runTransaction(async function(tx) {
    tx.set(runRef, Object.assign({}, rec, {
      createdAt: now,
      clientAt: new Date().toISOString(),
      appVersion: 'web-1.0.0'
    }));
    var statSnap = await tx.get(statRef);
    var prev = statSnap.exists ? statSnap.data() : { totalRuns: 0, bestScore: -1 };
    var next = {
      totalRuns: (prev.totalRuns || 0) + 1,
      bestScore: Math.max(prev.bestScore || -1, rec.score || 0),
      lastPlayedAt: now
    };
    tx.set(statRef, next, { merge: true });
  }).then(async function() {
    if (rec.publishToLeaderboard) {
      var prof = await getOrInitUserProfile();
      await db.collection('leaderboard_public').doc(uid).set({
        bestScore: rec.score,
        displayName: prof.displayName || '無名修士',
        country: prof.country || 'TW',
        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true });
    }
  }).catch(function(e){ console.warn('saveRunRecord 失敗：', e); });
}

// # 讀取我的資料（可在 UI 上顯示用）
async function loadMyRecentRuns(limitN) {
  if (!FIREBASE_ONLINE_ENABLED || !db) return [];
  var u = auth && auth.currentUser ? auth.currentUser : await ensureSignedIn();
  if (!u) return [];
  var qs = await db.collection('users').doc(u.uid).collection('runs').orderBy('createdAt','desc').limit(limitN||50).get();
  return qs.docs.map(function(d){ return Object.assign({id:d.id}, d.data()); });
}

async function loadMyStats() {
  if (!FIREBASE_ONLINE_ENABLED || !db) return { totalRuns: 0, bestScore: 0 };
  var u = auth && auth.currentUser ? auth.currentUser : await ensureSignedIn();
  if (!u) return { totalRuns: 0, bestScore: 0 };
  var doc = await db.collection('user_stats').doc(u.uid).get();
  return doc.exists ? doc.data() : { totalRuns: 0, bestScore: 0 };
}

async function loadLeaderboardTopN(n) {
  if (!FIREBASE_ONLINE_ENABLED || !db) return [];
  var qs = await db.collection('leaderboard_public').orderBy('bestScore','desc').limit(n||100).get();
  return qs.docs.map(function(d){ return Object.assign({id:d.id}, d.data()); });
}

// # 使用者 profile 檔案
async function getOrInitUserProfile() {
  if (!FIREBASE_ONLINE_ENABLED || !db) return { displayName: '無名修士', country: 'TW' };
  var u = auth && auth.currentUser ? auth.currentUser : await ensureSignedIn();
  if (!u) return { displayName: '無名修士', country: 'TW' };
  var ref = db.collection('users').doc(u.uid);
  var snap = await ref.get();
  if (snap.exists) return snap.data();
  var init = { displayName: u.displayName || '無名修士', createdAt: firebase.firestore.FieldValue.serverTimestamp(), avatarUrl: null, country: 'TW' };
  await ref.set(init, { merge: true });
  return init;
}

// # 本檔對接點：遊戲結束時呼叫（已由 showTrainingResult() 內部注入呼叫）
async function onGameFinished(payload) {
  try { await ensureSignedIn(); } catch (e) {}
  try { await saveRunRecord(payload); } catch (e) { console.warn(e); }
}

// # 一次性遷移：把既有 localStorage 的紀錄（如你有保存）上傳到雲端（可選）
async function migrateLocalToCloud() {
  try { await ensureSignedIn(); } catch (e) {}
  // # 若你有舊格式，可在這裡讀取 localStorage 的舊紀錄 key 並逐筆 saveRunRecord
  // # 目前此專案的主資料已存於 gameState / maxScores，不做額外遷移以避免重覆；如需自訂，請在此擴充。
}

// # 啟動時嘗試登入；若雲端未啟用則安靜略過
document.addEventListener('DOMContentLoaded', function() {
  // 頁面載入後先確認登入狀態，再進行資料遷移與 presence 初始化
  ensureSignedIn().then(function() {
    try { migrateLocalToCloud(); } catch(e){}
    // 初始化 presence 以統計線上人數
    try { initPresence(); } catch(e){}
  });
});
</script>
<!-- ==================== /Firebase 線上版整合區 ==================== -->
<!-- ==================== Supabase 整合區 ==================== -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// ===== Supabase 設定 =====
// 🚨 請將以下兩個常數替換為您在 Supabase 專案設定頁取得的 URL 與 ANON 金鑰
const SUPABASE_URL = 'https://twwvcgcbmupsvtnixzmj.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR3d3ZjZ2NibXVwc3Z0bml4em1qIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1MDAwNzgsImV4cCI6MjA3NjA3NjA3OH0.lCH_ht6jHJ7nf2yqOmLmoz441tMWv7b5Q6YRVDNkn_A';

// 停用 Firebase 相關變數以避免程式碼錯誤
window.FIREBASE_ONLINE_ENABLED = false;
window.db = null;
window.auth = null;

// 控制是否啟用雲端模式
window.ONLINE_ENABLED = true;

// 初始化 Supabase Client
var supabaseClient = null;
// # 用於追蹤目前線上人數的全域變數；將在 presence 事件觸發時更新
var onlineUsersCount = 0;
try {
  if (ONLINE_ENABLED) {
    supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  }
} catch (e) {
  console.warn('初始化 Supabase 失敗：', e);
  ONLINE_ENABLED = false;
}

async function ensureSignedIn() {
  if (!ONLINE_ENABLED || !supabaseClient) return null;
  try {
    const { data, error } = await supabaseClient.auth.getUser();
    if (error) { console.warn('取得 Supabase 使用者失敗：', error); return null; }
    return data.user || null;
  } catch (e) {
    console.warn('ensureSignedIn 發生錯誤：', e);
    return null;
  }
}

async function upgradeToEmailPassword(email, password) {
  if (!ONLINE_ENABLED || !supabaseClient) return null;
  try {
    let { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
    if (error) {
      let { data: signUpData, error: signUpError } = await supabaseClient.auth.signUp({ email, password });
      if (signUpError) { console.warn('註冊失敗：', signUpError); return null; }
      return signUpData.user;
    }
    return data.user;
  } catch (e) {
    console.warn('Email/密碼登入失敗', e);
    return null;
  }
}

function signOutOnline() {
  if (supabaseClient) {
    return supabaseClient.auth.signOut();
  }
}

async function loadMyStats() {
  if (!ONLINE_ENABLED || !supabaseClient) return { totalRuns: 0, bestScore: 0 };
  const user = await ensureSignedIn();
  if (!user) return { totalRuns: 0, bestScore: 0 };
  try {
    const { data, error } = await supabaseClient
      .from('user_stats')
      .select()
      .eq('id', user.id)
      .single();
    if (error && error.code !== 'PGRST116') {
      console.warn('讀取 user_stats 失敗：', error);
      return { totalRuns: 0, bestScore: 0 };
    }
    return data || { totalRuns: 0, bestScore: 0 };
  } catch (e) {
    console.warn('loadMyStats 發生錯誤：', e);
    return { totalRuns: 0, bestScore: 0 };
  }
}

async function loadLeaderboardTopN(n) {
  if (!ONLINE_ENABLED || !supabaseClient) return [];
  try {
    const { data, error } = await supabaseClient
      .from('leaderboard_public')
      .select()
      .order('bestScore', { ascending: false })
      .limit(n || 100);
    if (error) { console.warn('讀取排行榜失敗：', error); return []; }
    return (data || []).map(function(row) {
      return Object.assign({ id: row.id }, row);
    });
  } catch (e) {
    console.warn('loadLeaderboardTopN 發生錯誤：', e);
    return [];
  }
}

// ==================== Presence 初始化 ====================
// 使用 Supabase Realtime Presence 功能來追蹤當前線上人數。
// 進入 main menu 時會在 initPresence() 中訂閱 presence 事件。
async function initPresence() {
  // 只有在啟用雲端模式且 supabaseClient 初始化成功時才啟動 presence。
  if (!ONLINE_ENABLED || !supabaseClient) return;
  try {
    // 確保使用者登入狀態；若未登入則會回傳 null
    const user = await ensureSignedIn();
    // 使用者身份 ID 作為 presence key；若未登入則隨機產生 anon- 開頭的 key
    const presenceKey = (user && user.id) ? user.id : ('anon-' + Math.random().toString(36).substring(2, 10));
    // 建立實時頻道，啟用 presence 設定
    const channel = supabaseClient.channel('online_users', {
      config: {
        presence: { key: presenceKey }
      }
    });
    // 在 sync 事件時更新線上人數統計
    channel.on('presence', { event: 'sync' }, () => {
      try {
        const state = channel.presenceState();
        // presenceState 以 key 為索引；線上人數即為鍵的數量
        onlineUsersCount = Object.keys(state).length;
        const countEl = document.getElementById('onlineUsersCount');
        if (countEl) {
          countEl.textContent = `👥 目前線上人數：${onlineUsersCount}`;
        }
      } catch (err) {
        console.warn('更新線上人數失敗', err);
      }
    });
    // 訂閱頻道並在成功訂閱後追蹤自己的 presence
    await channel.subscribe((status) => {
      if (status === 'SUBSCRIBED') {
        // track() 的 payload 可包含自訂資料，此處不需要額外資訊
        channel.track({});
      }
    });
  } catch (e) {
    console.warn('初始化 presence 發生錯誤：', e);
  }
}

async function getOrInitUserProfile() {
  if (!ONLINE_ENABLED || !supabaseClient) return { displayName: '無名修士', country: 'TW' };
  const user = await ensureSignedIn();
  if (!user) return { displayName: '無名修士', country: 'TW' };
  const meta = user.user_metadata || {};
  return {
    displayName: meta.full_name || meta.displayName || user.email || '無名修士',
    country: meta.country || 'TW'
  };
}

async function saveRunRecord(rec) {
  if (!ONLINE_ENABLED || !supabaseClient) return;
  const user = await ensureSignedIn();
  if (!user) return;
  const uid = user.id;
  try {
    // 儲存遊戲紀錄到 runs 表；若不存在可忽略
    try {
      await supabaseClient.from('runs').insert([Object.assign({}, rec, {
        user_id: uid,
        createdAt: new Date().toISOString(),
        clientAt: new Date().toISOString(),
        appVersion: 'web-1.0.0'
      })]);
    } catch (_) {
      // runs 表可能不存在，忽略錯誤
    }
    // 更新 user_stats
    let totalRuns = 0;
    let bestScore = rec.score || 0;
    try {
      const { data: statsRow, error } = await supabaseClient
        .from('user_stats')
        .select('totalRuns, bestScore')
        .eq('id', uid)
        .single();
      if (!error && statsRow) {
        totalRuns = (statsRow.totalRuns || 0) + 1;
        bestScore = Math.max(statsRow.bestScore || -1, rec.score || 0);
      } else {
        totalRuns = 1;
        bestScore = rec.score || 0;
      }
    } catch (_) {
      totalRuns = 1;
      bestScore = rec.score || 0;
    }
    await supabaseClient.from('user_stats').upsert({
      id: uid,
      totalRuns: totalRuns,
      bestScore: bestScore,
      lastPlayedAt: new Date().toISOString()
    });
    // 發布到排行榜
    if (rec.publishToLeaderboard) {
      const prof = await getOrInitUserProfile();
      await supabaseClient.from('leaderboard_public').upsert({
        id: uid,
        bestScore: rec.score,
        displayName: prof.displayName || '無名修士',
        country: prof.country || 'TW',
        updatedAt: new Date().toISOString()
      });
    }
  } catch (e) {
    console.warn('saveRunRecord 發生錯誤：', e);
  }
}

async function migrateLocalToCloud() {
  // 暫不實作；如需遷移本機資料，請於此調用 saveRunRecord()。
}

document.addEventListener('DOMContentLoaded', function() {
  ensureSignedIn().then(function(){ try { migrateLocalToCloud(); } catch(e){} });
});
</script>
<!-- ==================== /Supabase 整合區 ==================== -->

</body>
</html>
