<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>運氣訓練工具 V9-0（修仙網頁版）</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --container-bg: #ffffff;
            --text-color: #333;
            --primary-color: #007bff;
            --primary-hover: #0056b3;
            --secondary-color: #6c757d;
            --secondary-hover: #545b62;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --gold-color: #DAA520;
            --teal-color: #20c997;
            --purple-color: #6f42c1;
            --border-radius: 8px;
            --box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        #app-container {
            width: 100%;
            max-width: 700px;
            background-color: var(--container-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 20px;
            box-sizing: border-box;
        }

        h1, h2, h3 {
            text-align: center;
            margin-top: 0;
        }

        button {
            display: block;
            width: 100%;
            padding: 12px;
            font-size: 16px;
            margin: 8px 0;
            border-radius: 6px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            background-color: var(--primary-color);
            color: white;
            -webkit-tap-highlight-color: transparent; /* 移除行動裝置點擊高亮 */
        }
        button:hover {
            background-color: var(--primary-hover);
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .btn-warning { background-color: var(--warning-color); color: #333; }
        .btn-warning:hover { background-color: #e0a800; }
        .btn-danger { background-color: var(--danger-color); }
        .btn-danger:hover { background-color: #b22a38; }
        .btn-secondary { background-color: var(--secondary-color); }
        .btn-secondary:hover { background-color: var(--secondary-hover); }


        .info-section {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: var(--border-radius);
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }
        
        .info-section p {
            margin: 6px 0;
        }

        progress {
            width: 100%;
            height: 18px;
            border-radius: 9px;
            overflow: hidden;
            border: none;
        }
        progress::-webkit-progress-bar {
            background-color: #e9ecef;
        }
        progress::-webkit-progress-value {
            background-color: var(--success-color);
            transition: width 0.5s ease-in-out;
        }
        progress::-moz-progress-bar {
            background-color: var(--success-color);
        }

        .game-grid {
            display: grid;
            gap: 10px;
            margin: 20px 0;
        }

        .grid-btn {
            width: 100%;
            height: 60px;
            font-size: 24px;
            padding: 0;
            background-color: #f8f9fa;
            color: var(--text-color);
            border: 1px solid #ccc;
        }
        .grid-btn:hover {
            background-color: #e2e6ea;
        }
        .grid-btn.selected {
            border-color: var(--primary-color);
            background-color: #e0f7fa;
            box-shadow: 0 0 5px var(--primary-color);
        }
        .grid-btn.hint-correct {
            border: 2px solid var(--gold-color);
            background-color: #fff7d6;
        }
        .grid-btn.hint-wrong {
            border: 2px solid var(--danger-color);
            background-color: #ffe6e6;
        }
        .grid-btn.checked {
            background-color: #d1ecf1;
            border-color: var(--info-color);
        }


        .feedback {
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .feedback.success { color: var(--success-color); }
        .feedback.error { color: var(--danger-color); }
        .feedback.info { color: var(--info-color); }
        
        .message {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .msg-daily { color: #004085; background-color: #cce5ff; border: 1px solid #b8daff; }
        .msg-shop { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb; }
        .msg-shop-fail { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; }
        .msg-levelup { color: var(--purple-color); font-weight: bold; }
        .msg-reward { color: var(--gold-color); font-weight: bold; }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fff;
            margin: auto;
            padding: 20px;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .modal-header h2 { margin: 0; font-size: 1.5em; }
        .modal-body {
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-item-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .modal-item-row label { flex-grow: 1; }
        .modal-item-row input[type="number"] {
            width: 70px;
            padding: 5px;
            text-align: right;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .modal-footer {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .close-btn {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
        .close-btn:hover { color: #000; }

    </style>
</head>
<body>

    <div id="app-container">
        <div id="app"></div>
    </div>

    <!-- Modal Template -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title"></h2>
                <button class="close-btn" id="modal-close-btn">&times;</button>
            </div>
            <div id="modal-body" class="modal-body"></div>
            <div id="modal-footer" class="modal-footer"></div>
        </div>
    </div>

<script>
// =================================================================================
// 運氣訓練工具 V9-0 - JavaScript 離線網頁版
// 作者：Gemini (移植自使用者提供的 Python 腳本)
// 版本：1.2 - 修正訓練模式中答案位置規律排列的問題，實現真正隨機。
// =================================================================================

document.addEventListener('DOMContentLoaded', () => {

// ===================== 遊戲核心設定與數據 (來自 Python) =====================
const SCORE_FILE = "max_scores"; // localStorage key
const STATS_FILE = "training_stats"; // localStorage key

const DIFFICULTY_WIN_RATE = {1:90, 2:80, 3:65, 4:50, 5:35, 6:25, 7:15, 8:10, 9:7, 10:5};
const REDEEM_1_COST = 50;
const REDEEM_5_COST = 200;
const STONE_EXCHANGE_COST = 100;

const TRAINING_MILESTONES = {
    5: {"rewards": 1, "title": "1.宗門的基石"}, 10: {"rewards": 1, "title": "2.見習弟子"}, 25: {"rewards": 2, "title": "3.外門雜役"}, 50: {"rewards": 2, "title": "4.外門弟子"}, 75: {"rewards": 3, "title": "5.外門師兄"}, 100: {"rewards": 5, "title": "6.外門菁英"}, 150: {"rewards": 3, "title": "7.內門候補"}, 200: {"rewards": 4, "title": "8.內門弟子"}, 300: {"rewards": 5, "title": "9.內門師兄"}, 400: {"rewards": 5, "title": "10.內門菁英"}, 500: {"rewards": 10, "title": "11.宗門執事"}, 600: {"rewards": 5, "title": "12.任務堂弟子"}, 700: {"rewards": 5, "title": "13.傳法堂弟子"}, 800: {"rewards": 5, "title": "14.煉丹閣弟子"}, 900: {"rewards": 5, "title": "15.煉器坊弟子"}, 1000: {"rewards": 15, "title": "16.親傳弟子"}, 1200: {"rewards": 6, "title": "17.戒律堂執事"}, 1400: {"rewards": 6, "title": "18.藏經閣執事"}, 1600: {"rewards": 6, "title": "19.百草園管事"}, 1800: {"rewards": 6, "title": "20.萬獸山管事"}, 2000: {"rewards": 20, "title": "21.首席大弟子"}, 2500: {"rewards": 10, "title": "22.任務堂長老"}, 3000: {"rewards": 10, "title": "23.傳法堂長老"}, 3500: {"rewards": 10, "title": "24.煉丹閣長老"}, 4000: {"rewards": 10, "title": "25.煉器坊長老"}, 5000: {"rewards": 25, "title": "26.宗門長老"}, 6000: {"rewards": 12, "title": "27.刑法長老"}, 7000: {"rewards": 12, "title": "28.傳功長老"}, 8000: {"rewards": 12, "title": "29.客卿長老"}, 9000: {"rewards": 12, "title": "30.巡山長老"}, 10000: {"rewards": 30, "title": "31.宗門護法"}, 12500: {"rewards": 15, "title": "32.丹道峰主"}, 15000: {"rewards": 15, "title": "33.器道峰主"}, 17500: {"rewards": 15, "title": "34.劍道峰主"}, 20000: {"rewards": 40, "title": "35.太上長老"}, 25000: {"rewards": 20, "title": "36.宗門聖子"}, 30000: {"rewards": 20, "title": "37.宗門聖女"}, 35000: {"rewards": 20, "title": "38.行走的傳說"}, 40000: {"rewards": 20, "title": "39.護道人"}, 50000: {"rewards": 50, "title": "40.代宗主"}, 60000: {"rewards": 25, "title": "41.鎮派老祖"}, 70000: {"rewards": 25, "title": "42.開派祖師"}, 80000: {"rewards": 25, "title": "43.渡劫真仙"}, 90000: {"rewards": 25, "title": "44.飛升之人"}, 100000: {"rewards": 100, "title": "45.人間之神"}, 120000: {"rewards": 50, "title": "46.天界行者"}, 140000: {"rewards": 50, "title": "47.星界遊神"}, 160000: {"rewards": 50, "title": "48.位面之主"}, 180000: {"rewards": 50, "title": "49.時空旅者"}, 200000: {"rewards": 100, "title": "50.萬古傳說"}, 250000: {"rewards": 100, "title": "51.因果之手"}, 300000: {"rewards": 100, "title": "52.命運編織者"}, 400000: {"rewards": 100, "title": "53規則制定者"}, 500000: {"rewards": 100, "title": "54.大道之源"}, 1000000: {"rewards": 500, "title": "55.終極造物主"},
};

const CULTIVATION_STAGES = (() => {
    let stages = [[0, 0, "凡人初入道"]];
    const LEVELS_PER_STAGE = 10;
    const score_cycle = Object.values(DIFFICULTY_WIN_RATE);
    let base_need_exp = 0;
    let need_step = 10;
    const stage_names = ["1.凡人", "2.練氣", "3.築基", "4.結丹", "5.元嬰", "6.化神", "7.煉虛", "8.合體", "9.大乘", "10.渡劫", "11.真仙", "12.金仙", "13.太乙金仙", "14.大羅金仙", "15.混元大羅", "16.仙王", "17.仙帝", "18.天尊", "19.祖仙", "20.無上", "21.超脫輪迴", "22.無上極境", "23.混沌無極", "24.大道歸一", "25.宇宙之主", "26.創世真神", "27.界外天尊", "28.混元道尊", "29.始源帝尊", "30.太初聖皇", "31.永恆之神", "32.混沌主宰", "33.萬道歸宗", "34.終極造物主", "35.無限永存者", "36.超維觀察者", "37.超越者", "38.真理化身", "39.虛無之神", "40.界上界主", "41.唯一真神","42.太上道祖","43.永劫不朽","44.無極本源","45.多元彼岸主","46.原初意志", "47.萬界始祖","48.終焉創世者","49.絕對真理","50.超越唯一","51.永恆王座"];
    stage_names.forEach(stage => {
        for (let sub = 1; sub <= LEVELS_PER_STAGE; sub++) {
            base_need_exp += need_step;
            const need_score = score_cycle[stages.length % score_cycle.length];
            stages.push([base_need_exp, need_score, `${stage}${sub}層`]);
        }
        need_step = Math.max(need_step + 1, Math.floor(need_step * 1.5));
    });
    return stages;
})();

const GRADE_NAMES = ["入品", "下品", "中品", "上品", "極品", "超品", "絕品", "寶品", "地品", "天品"];
const ITEM_TYPE_ORDER = ['兵器', '功法', '陣法', '仙丹', '靈器', '靈符'];

const WEAPONS = {
    "入品青竹劍": {"type": "multi_choice", "n": 1, "exp_cost": 100, "upgrade_cost": 2000, "desc": "增加1次作答次數"}, "入品銅背刀": {"type": "multi_choice", "n": 1, "exp_cost": 100, "upgrade_cost": 2000, "desc": "增加1次作答次數"}, "入品碎雲槍": {"type": "multi_choice", "n": 1, "exp_cost": 100, "upgrade_cost": 2000, "desc": "增加1次作答次數"},
    "下品寒鋒劍": {"type": "multi_choice", "n": 2, "exp_cost": 200, "upgrade_cost": 4000, "desc": "增加2次作答次數"}, "下品裂石刀": {"type": "multi_choice", "n": 2, "exp_cost": 200, "upgrade_cost": 4000, "desc": "增加2次作答次數"}, "下品游龍槍": {"type": "multi_choice", "n": 2, "exp_cost": 200, "upgrade_cost": 4000, "desc": "增加2次作答次數"},
    "中品青霜劍": {"type": "multi_choice", "n": 3, "exp_cost": 400, "upgrade_cost": 8000, "desc": "增加3次作答次數"}, "中品赤焰刀": {"type": "multi_choice", "n": 3, "exp_cost": 400, "upgrade_cost": 8000, "desc": "增加3次作答次數"}, "中品霆罡槍": {"type": "multi_choice", "n": 3, "exp_cost": 400, "upgrade_cost": 8000, "desc": "增加3次作答次數"},
    "上品流光劍": {"type": "multi_choice", "n": 4, "exp_cost": 800, "upgrade_cost": 16000, "desc": "增加4次作答次數"}, "上品蒼鯨刀": {"type": "multi_choice", "n": 4, "exp_cost": 800, "upgrade_cost": 16000, "desc": "增加4次作答次數"}, "上品破軍槍": {"type": "multi_choice", "n": 4, "exp_cost": 800, "upgrade_cost": 16000, "desc": "增加4次作答次數"},
    "極品離火飛劍": {"type": "multi_choice", "n": 5, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "增加5次作答次數"}, "極品玄冥鬼刀": {"type": "multi_choice", "n": 5, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "增加5次作答次數"}, "極品紫電神槍": {"type": "multi_choice", "n": 5, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "增加5次作答次數"},
    "超品太虛劍胚": {"type": "multi_choice", "n": 6, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "增加6次作答次數"}, "超品無相刀胎": {"type": "multi_choice", "n": 6, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "增加6次作答次數"}, "超品天罡槍魂": {"type": "multi_choice", "n": 6, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "增加6次作答次數"},
    "絕品太白星劍": {"type": "multi_choice", "n": 7, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "增加7次作答次數"}, "絕品玄武鎮海刀": {"type": "multi_choice", "n": 7, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "增加7次作答次數"}, "絕品青龍驚雷槍": {"type": "multi_choice", "n": 7, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "增加7次作答次數"},
    "寶品懸天飛仙劍": {"type": "multi_choice", "n": 8, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "增加8次作答次數"}, "寶品戮神血月刀": {"type": "multi_choice", "n": 8, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "增加8次作答次數"}, "寶品破界鎏金槍": {"type": "multi_choice", "n": 8, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "增加8次作答次數"},
    "地品崑崙斬邪劍": {"type": "multi_choice", "n": 9, "exp_cost": 25600, "upgrade_cost": 512000, "desc": "增加9次作答次數"}, "地品厚土鎮岳刀": {"type": "multi_choice", "n": 9, "exp_cost": 25600, "upgrade_cost": 512000, "desc": "增加9次作答次數"}, "地品後土誓盟槍": {"type": "multi_choice", "n": 9, "exp_cost": 25600, "upgrade_cost": 512000, "desc": "增加9次作答次數"},
    "天品太清誅仙劍": {"type": "multi_choice", "n": 10, "exp_cost": 51200, "upgrade_cost": 0, "desc": "增加10次作答次數"}, "天品天道審刑刀": {"type": "multi_choice", "n": 10, "exp_cost": 51200, "upgrade_cost": 0, "desc": "增加10次作答次數"}, "天品乾坤定海槍": {"type": "multi_choice", "n": 10, "exp_cost": 51200, "upgrade_cost": 0, "desc": "增加10次作答次數"},
};
const TECHNIQUES = {
    "入品築基吐納訣": {"type": "reveal_wrong", "n": 1, "exp_cost": 0, "upgrade_cost": 1000, "desc": "顯現1個錯誤答案"}, "入品松鹤長青功": {"type": "reveal_wrong", "n": 1, "exp_cost": 0, "upgrade_cost": 1000, "desc": "顯現1個錯誤答案"},
    "下品小周天行氣": {"type": "reveal_wrong", "n": 2, "exp_cost": 100, "upgrade_cost": 2000, "desc": "顯現2個錯誤答案"}, "下品青木養元術": {"type": "reveal_wrong", "n": 2, "exp_cost": 100, "upgrade_cost": 2000, "desc": "顯現2個錯誤答案"},
    "中品玄息歸一訣": {"type": "reveal_wrong", "n": 3, "exp_cost": 200, "upgrade_cost": 4000, "desc": "顯現3個錯誤答案"}, "中品赤陽煉體篇": {"type": "reveal_wrong", "n": 3, "exp_cost": 200, "upgrade_cost": 4000, "desc": "顯現3個錯誤答案"},
    "上品三花聚頂訣": {"type": "reveal_wrong", "n": 4, "exp_cost": 400, "upgrade_cost": 8000, "desc": "顯現4個錯誤答案"}, "上品紫府還真經": {"type": "reveal_wrong", "n": 4, "exp_cost": 400, "upgrade_cost": 8000, "desc": "顯現4個錯誤答案"},
    "極品太陰煉月經": {"type": "reveal_wrong", "n": 5, "exp_cost": 800, "upgrade_cost": 16000, "desc": "顯現5個錯誤答案"}, "極品離火冥雷經": {"type": "reveal_wrong", "n": 5, "exp_cost": 800, "upgrade_cost": 16000, "desc": "顯現5個錯誤答案"},
    "超品太乙歸元經": {"type": "reveal_wrong", "n": 6, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "顯現6個錯誤答案"}, "超品無相玄功": {"type": "reveal_wrong", "n": 6, "exp_cost": 1600, "upgrade_cost": 32000, "desc": "顯現6個錯誤答案"},
    "絕品九轉金身訣": {"type": "reveal_wrong", "n": 7, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "顯現7個錯誤答案"}, "絕品五雷正法": {"type": "reveal_wrong", "n": 7, "exp_cost": 3200, "upgrade_cost": 64000, "desc": "顯現7個錯誤答案"},
    "寶品洞天造化經": {"type": "reveal_wrong", "n": 8, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "顯現8個錯誤答案"}, "寶品先天一炁訣": {"type": "reveal_wrong", "n": 8, "exp_cost": 6400, "upgrade_cost": 128000, "desc": "顯現8個錯誤答案"},
    "地品地藏冥心經": {"type": "reveal_wrong", "n": 9, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "顯現9個錯誤答案"}, "地品厚土無疆訣": {"type": "reveal_wrong", "n": 9, "exp_cost": 12800, "upgrade_cost": 256000, "desc": "顯現9個錯誤答案"},
    "天品大道混元藏": {"type": "reveal_wrong", "n": 10, "exp_cost": 25600, "upgrade_cost": 0, "desc": "顯現10個錯誤答案"}, "天品無極本源經": {"type": "reveal_wrong", "n": 10, "exp_cost": 25600, "upgrade_cost": 0, "desc": "顯現10個錯誤答案"},
};
const FORMATIONS = {
    "入品三才聚靈陣": {"type": "add_time", "n": 1, "exp_cost": 10, "upgrade_cost": 200, "desc": "增加1秒作答時間"}, "入品四門陷敵陣": {"type": "add_time", "n": 1, "exp_cost": 10, "upgrade_cost": 200, "desc": "增加1秒作答時間"},
    "下品五行護山陣": {"type": "add_time", "n": 2, "exp_cost": 20, "upgrade_cost": 400, "desc": "增加2秒作答時間"}, "下品六甲迷踪陣": {"type": "add_time", "n": 2, "exp_cost": 20, "upgrade_cost": 400, "desc": "增加2秒作答時間"},
    "中品七曜星門陣": {"type": "add_time", "n": 3, "exp_cost": 40, "upgrade_cost": 800, "desc": "增加3秒作答時間"}, "中品八門金鎖陣": {"type": "add_time", "n": 3, "exp_cost": 40, "upgrade_cost": 800, "desc": "增加3秒作答時間"},
    "上品九宮幻天陣": {"type": "add_time", "n": 4, "exp_cost": 80, "upgrade_cost": 1600, "desc": "增加4秒作答時間"}, "上品十二天罡陣": {"type": "add_time", "n": 4, "exp_cost": 80, "upgrade_cost": 1600, "desc": "增加4秒作答時間"},
    "極品玄武鎮海陣": {"type": "add_time", "n": 5, "exp_cost": 160, "upgrade_cost": 3200, "desc": "增加5秒作答時間"}, "極品白虎裂天陣": {"type": "add_time", "n": 5, "exp_cost": 160, "upgrade_cost": 3200, "desc": "增加5秒作答時間"},
    "超品青龍騰雲陣": {"type": "add_time", "n": 6, "exp_cost": 320, "upgrade_cost": 6400, "desc": "增加6秒作答時間"}, "超品朱雀焚天陣": {"type": "add_time", "n": 6, "exp_cost": 320, "upgrade_cost": 6400, "desc": "增加6秒作答時間"},
    "絕品四象合一鎮域陣": {"type": "add_time", "n": 7, "exp_cost": 640, "upgrade_cost": 12800, "desc": "增加7秒作答時間"}, "絕品太乙混元封天陣": {"type": "add_time", "n": 7, "exp_cost": 640, "upgrade_cost": 12800, "desc": "增加7秒作答時間"},
    "寶品萬靈歸源陣": {"type": "add_time", "n": 8, "exp_cost": 1280, "upgrade_cost": 25600, "desc": "增加8秒作答時間"}, "寶品先天兩儀反演陣": {"type": "add_time", "n": 8, "exp_cost": 1280, "upgrade_cost": 25600, "desc": "增加8秒作答時間"},
    "地品九地鎮魔大陣": {"type": "add_time", "n": 9, "exp_cost": 2560, "upgrade_cost": 51200, "desc": "增加9秒作答時間"}, "地品厚土歸墟陣": {"type": "add_time", "n": 9, "exp_cost": 2560, "upgrade_cost": 51200, "desc": "增加9秒作答時間"},
    "天品先天一炁化劫大陣": {"type": "add_time", "n": 10, "exp_cost": 5120, "upgrade_cost": 0, "desc": "增加10秒作答時間"}, "天品無極乾坤界域陣": {"type": "add_time", "n": 10, "exp_cost": 5120, "upgrade_cost": 0, "desc": "增加10秒作答時間"},
};

const UPGRADE_PATHS = {
    "入品青竹劍": "下品寒鋒劍", "下品寒鋒劍": "中品青霜劍", "中品青霜劍": "上品流光劍", "上品流光劍": "極品離火飛劍", "極品離火飛劍": "超品太虛劍胚", "超品太虛劍胚": "絕品太白星劍", "絕品太白星劍": "寶品懸天飛仙劍", "寶品懸天飛仙劍": "地品崑崙斬邪劍", "地品崑崙斬邪劍": "天品太清誅仙劍",
    "入品銅背刀": "下品裂石刀", "下品裂石刀": "中品赤焰刀", "中品赤焰刀": "上品蒼鯨刀", "上品蒼鯨刀": "極品玄冥鬼刀", "極品玄冥鬼刀": "超品無相刀胎", "超品無相刀胎": "絕品玄武鎮海刀", "絕品玄武鎮海刀": "寶品戮神血月刀", "寶品戮神血月刀": "地品厚土鎮岳刀", "地品厚土鎮岳刀": "天品天道審刑刀",
    "入品碎雲槍": "下品游龍槍", "下品游龍槍": "中品霆罡槍", "中品霆罡槍": "上品破軍槍", "上品破軍槍": "極品紫電神槍", "極品紫電神槍": "超品天罡槍魂", "超品天罡槍魂": "絕品青龍驚雷槍", "絕品青龍驚雷槍": "寶品破界鎏金槍", "寶品破界鎏金槍": "地品後土誓盟槍", "地品後土誓盟槍": "天品乾坤定海槍",
    "入品築基吐納訣": "下品小周天行氣", "下品小周天行氣": "中品玄息歸一訣", "中品玄息歸一訣": "上品三花聚頂訣", "上品三花聚頂訣": "極品太陰煉月經", "極品太陰煉月經": "超品太乙歸元經", "超品太乙歸元經": "絕品九轉金身訣", "絕品九轉金身訣": "寶品洞天造化經", "寶品洞天造化經": "地品地藏冥心經", "地品地藏冥心經": "天品大道混元藏",
    "入品松鹤長青功": "下品青木養元術", "下品青木養元術": "中品赤陽煉體篇", "中品赤陽煉體篇": "上品紫府還真經", "上品紫府還真經": "極品離火冥雷經", "極品離火冥雷經": "超品無相玄功", "超品無相玄功": "絕品五雷正法", "絕品五雷正法": "寶品先天一炁訣", "寶品先天一炁訣": "地品厚土無疆訣", "地品厚土無疆訣": "天品無極本源經",
    "入品三才聚靈陣": "下品五行護山陣", "下品五行護山陣": "中品七曜星門陣", "中品七曜星門陣": "上品九宮幻天陣", "上品九宮幻天陣": "極品玄武鎮海陣", "極品玄武鎮海陣": "超品青龍騰雲陣", "超品青龍騰雲陣": "絕品四象合一鎮域陣", "絕品四象合一鎮域陣": "寶品萬靈歸源陣", "寶品萬靈歸源陣": "地品九地鎮魔大陣", "地品九地鎮魔大陣": "天品先天一炁化劫大陣",
    "入品四門陷敵陣": "下品六甲迷踪陣", "下品六甲迷踪陣": "中品八門金鎖陣", "中品八門金鎖陣": "上品十二天罡陣", "上品十二天罡陣": "極品白虎裂天陣", "極品白虎裂天陣": "超品朱雀焚天陣", "超品朱雀焚天陣": "絕品太乙混元封天陣", "絕品太乙混元封天陣": "寶品先天兩儀反演陣", "寶品先天兩儀反演陣": "地品厚土歸墟陣", "地品厚土歸墟陣": "天品無極乾坤界域陣",
};

const ITEM_EFFECTS = {
    "入品仙丹": {"type": "exp", "n": 10, "desc": "增加 10 修煉經驗"}, "下品仙丹": {"type": "exp", "n": 30, "desc": "增加 30 修煉經驗"}, "中品仙丹": {"type": "exp", "n": 70, "desc": "增加 70 修煉經驗"}, "上品仙丹": {"type": "exp", "n": 150, "desc": "增加 150 修煉經驗"}, "極品仙丹": {"type": "exp", "n": 310, "desc": "增加 310 修煉經驗"}, "超品仙丹": {"type": "exp", "n": 630, "desc": "增加 630 修煉經驗"}, "絕品仙丹": {"type": "exp", "n": 1270, "desc": "增加 1270 修煉經驗"}, "寶品仙丹": {"type": "exp", "n": 2550, "desc": "增加 2550 修煉經驗"}, "地品仙丹": {"type": "exp", "n": 5110, "desc": "增加 5110 修煉經驗"}, "天品仙丹": {"type": "exp", "n": 10230, "desc": "增加 10230 修煉經驗"},
    "入品靈符": {"type": "wrong", "n": 1, "desc": "排除 1 個錯誤答案"}, "下品靈符": {"type": "wrong", "n": 2, "desc": "排除 2 個錯誤答案"}, "中品靈符": {"type": "wrong", "n": 3, "desc": "排除 3 個錯誤答案"}, "上品靈符": {"type": "wrong", "n": 4, "desc": "排除 4 個錯誤答案"}, "極品靈符": {"type": "wrong", "n": 5, "desc": "排除 5 個錯誤答案"}, "超品靈符": {"type": "wrong", "n": 6, "desc": "排除 6 個錯誤答案"}, "絕品靈符": {"type": "wrong", "n": 7, "desc": "排除 7 個錯誤答案"}, "寶品靈符": {"type": "wrong", "n": 8, "desc": "排除 8 個錯誤答案"}, "地品靈符": {"type": "wrong", "n": 9, "desc": "排除 9 個錯誤答案"}, "天品靈符": {"type": "wrong", "n": 10, "desc": "排除 10 個錯誤答案"},
    "入品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "下品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "中品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "上品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "極品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "超品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "絕品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "寶品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "地品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"}, "天品靈器": {"type": "correct", "n": 0, "desc": "顯示全部正確答案"},
    ...WEAPONS, ...TECHNIQUES, ...FORMATIONS
};

const ITEM_STONE_PRICES = {
    "入品仙丹": 3, "下品仙丹": 6, "中品仙丹": 12, "上品仙丹": 24, "極品仙丹": 48, "超品仙丹": 96, "絕品仙丹": 192, "寶品仙丹": 384, "地品仙丹": 768, "天品仙丹": 1536,
    "入品靈符": 1, "下品靈符": 2, "中品靈符": 4, "上品靈符": 8, "極品靈符": 16, "超品靈符": 32, "絕品靈符": 64, "寶品靈符": 128, "地品靈符": 256, "天品靈符": 512,
    "入品靈器": 5, "下品靈器": 10, "中品靈器": 20, "上品靈器": 40, "極品靈器": 80, "超品靈器": 160, "絕品靈器": 320, "寶品靈器": 640, "地品靈器": 1280, "天品靈器": 2560,
};

const ITEM_RENAME_MAP = {
    "普通仙丹": "入品仙丹", "普通靈符": "入品靈符", "普通靈器": "入品靈器",
};

const EMOJIS = ["😀","😂","😎","😡","😭","😍","😱","😴","😇","🤖"];
const ANIMALS = ["🐶","🐱","🐭","🐹","🐰","🦊","🐻","🐼","🐨","🐯","🦁","🐮","🐷","🐸","🐵","🦄","🐔","🐧","🐦","🐤"];
const FOODS = ["🍎","🍊","🍌","🍉","🍇","🍓","🥑","🍍","🥝","🍒","🍔","🍟","🍕","🌭","🥪","🥗","🍣","🍱","🥟","🍜"];
const COLORS = ["🔴","🟠","🟡","🟢","🔵","🟣","⚫","⚪","🟤","🟥","🟧","🟨","🟩","🟦","🟪","⬛","⬜","🟫","🔶","🔷"];
const SHAPES = ["🔺","🔵","⬛","⭐","🟩","🟧","🟥","⬜","🔶","🔷","🔳","🔲","🟫","🔸","🔹","⬟","⬢","⬣","⏺","⏹"];
const PLACES = ["🏠","🏢","🏬","🏭","🏰","🏯","🏝️","🏖️","⛩️","🎡","🎢","🎠","🗽","🗼","⛲","🕌","⛪","🛕","🏕️"];
const FLAGS = ["🇹🇼","🇯🇵","🇰🇷","🇨🇳","🇺🇸","🇬🇧","🇫🇷","🇩🇪","🇮🇹","🇪🇸","🇧🇷","🇨🇦","🇦🇺","🇳🇿","🇷🇺","🇸🇪","🇳🇴","🇮🇳","🇲🇽","🇿🇦"];
const NATURE = ["🌞","🌝","🌧️","⛈️","🌪️","🌈","🌊","🌋","❄️","🍃"];
const CARDS = ["🂱","🂲","🂳","🂴","🂵","🂶","🂷","🂸","🂹","🂺","🂻","🂼","🂽","🂾","🂡","🂢","🂣","🂤","🂥","🂦","🂧","🂨","🂩","🂪","🂫","🂬","🂭","🂮","🃁","🃂","🃃","🃄","🃅","🃆","🃇","🃈","🃉","🃊","🃋","🃌","🃍","🃎","🃑","🃒","🃓","🃔","🃕","🃖","🃗","🃘","🃙","🃚","🃛","🃜","🃝","🃞","🂠","🃏","🃟"];
const MAHJONG = ["🀇","🀈","🀉","🀊","🀋","🀌","🀍","🀎","🀏","🀙","🀚","🀛","🀜","🀝","🀞","🀟","🀠","🀡","🀐","🀑","🀒","🀓","🀔","🀕","🀖","🀗","🀘","🀀","🀁","🀂","🀃","🀄","🀅","🀆"];
const VEHICLES = ["🚗","🚕","🚙","🚌","🚎","🏎️","🚓","🚑","🚒","🚐","🚚","🚛","🚜","🛻","🛺","🚲","🛵","🏍️","🚔","🚍","✈️","🛫","🛬","🛩️","🚁","🛶","🚤","⛵","🛳️","🚀"];
const ZODIACS = ["♈","♉","♊","♋","♌","♍","♎","♏","♐","♑","♒","♓"];
const CLOCKS = ["🕛","🕐","🕑","🕒","🕓","🕔","🕕","🕖","🕗","🕘","🕙","🕚"];
const PROFESSIONS = ["🧑‍⚕️","🧑‍🏫","🧑‍🍳","🧑‍💻","🧑‍🔬","🧑‍🎨","🧑‍🚒","🧑‍✈️","🧑‍🚀","🧑‍🔧","🧑‍🌾","🧑‍🏭","🧑‍⚖️","🧑‍🎤","🧑‍🎓","👮‍♂️","👷‍♂️"];
const SPORTS = ["🎖️","🏆","🏅","🥇","🥈","🥉","⚽","⚾","🥎","🏀","🏐","🏈","🏉","🎾","🥏","🎳","🏏","🏑","🏒","🥍","🏓","🏸","🥊","🥋","🥅","⛳","⛸️","🎣","🤿","🎽","🎿","🛷","🥌","🎯"];
const OFFICE = ["📔","📕","📖","📗","📘","📙","📚","📓","📒","📃","📜","📄","📰","🗞️","📑","🔖","🏷️","✉️","📧","📨","📩","📤","📥","📦","📫","📪","📬","📭","📮","🗳️","✏️","✒️","🖋️","🖊️","🖌️","🖍️","📝","💼","📁","📂","🗂️","📅","📆","🗒️","🗓️","📇","📈","📉","📊","📋","📌","📍","📎","🖇️","📏","📐","✂️","🗃️","🗄️","🗑️","🪪"];
const TOOLS = ["🧳","🌡️","🧸","🧶","🪢","🔍","🔎","🕯️","💡","🔦","🔒","🔓","🔏","🔐","🔑","🗝️","🔨","🪓","⛏️","⚒️","🛠️","🗡️","⚔️","💣","🪃","🏹","🛡️","🪚","🔧","🪛","🔩","⚙️","🗜️","⚖️","🔗","⛓️","💥","⛓️","🪝","🧰","🧲","🪜","🪏","⚗️","🧪","🧫","🔬","🔭","📡","💉","🩹","🩼","🩺","🩻","🚪","🪞","🪟","🛏️","🛋️","🪑","🚽","🪠","🚿","🛁","🪤","🪒","🧴","🧷","🧹","🧺","🧻","🪣","🧼","🫧","🪥","🧽","🧯","🛒","🚬","⚰️","🪦","⚱️","🪧"];
// 自動拆分辦公文具與工具/家居用品為前半(A)與後半(B)
const OFFICE_A = OFFICE.slice(0, Math.ceil(OFFICE.length / 2));
const OFFICE_B = OFFICE.slice(Math.ceil(OFFICE.length / 2));
const TOOLS_A = TOOLS.slice(0, Math.ceil(TOOLS.length / 2));
const TOOLS_B = TOOLS.slice(Math.ceil(TOOLS.length / 2));


const ALL_GAMES = [
    { name: "從 1～10 選出正確號碼", func: "game_guess_hidden" }, { name: "從 1～20 選出正確號碼", func: "game_guess_20" }, { name: "從 1～30 選出正確號碼", func: "game_guess_30" }, { name: "寶箱訓練：選出正確的", func: "game_treasure_box" }, { name: "選出好運表情符號", func: "game_emoji_pick" }, { name: "選出幸運動物", func: "game_animals" }, { name: "選出幸運食物", func: "game_foods" }, { name: "選出幸運地點", func: "game_places" }, { name: "選出幸運圖形", func: "game_shape_select" }, { name: "找出幸運顏色", func: "game_color_select" }, { name: "選出幸運國旗", func: "game_flags" }, { name: "選出幸運自然現象", func: "game_nature" }, { name: "選出幸運撲克牌符號", func: "game_cards" }, { name: "選出幸運麻將圖案", func: "game_mahjong" }, { name: "選出幸運交通工具", func: "game_vehicles" }, { name: "選出幸運星座符號", func: "game_zodiacs" }, { name: "禮物訓練：選出幸運禮物號碼", func: "game_gift_box" }, { name: "挑選今天幸運時段", func: "game_lucky_period" }, { name: "選出幸運職業", func: "game_professions" }, { name: "選出體育與獎項", func: "game_sports_awards" }, { name: "選出辦公文具A", func: "game_office_a" }, { name: "選出辦公文具B", func: "game_office_b" }, { name: "選出工具、家居用品及其他A", func: "game_tools_a" }, { name: "選出工具、家居用品及其他B", func: "game_tools_b" }, 
];


// ===================== 遊戲狀態管理 =====================
let gameState;
let maxScores;
let trainingState;
let timers = {
    answer: null,
    nextRound: null,
};

// 預設遊戲狀態
const defaultStats = {
    total: 0, exp: 0, bonus: 0, luck_tests_total: 0,
    luck_history: [], luck_tickets: 0, luck_tickets_total: 0,
    stage_idx: 0, last_daily_ticket_date: "", inventory: {},
    inventory_order: [], stones: 0, current_title: "1.宗門的基石",
    last_luck_date: "", last_luck_reward_msg: ""
};

function saveToLocalStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
        console.error("Failed to save to localStorage", e);
    }
}

function loadFromLocalStorage(key, defaultValue = {}) {
    const data = localStorage.getItem(key);
    try {
        return data ? JSON.parse(data) : defaultValue;
    } catch (e) {
        console.error("Failed to parse from localStorage", e);
        return defaultValue;
    }
}

function saveGameState() {
    saveToLocalStorage(STATS_FILE, gameState);
    saveToLocalStorage(SCORE_FILE, maxScores);
}

function loadGameState() {
    gameState = loadFromLocalStorage(STATS_FILE, JSON.parse(JSON.stringify(defaultStats)));
    maxScores = loadFromLocalStorage(SCORE_FILE, {});
    // 兼容舊版道具名稱
    const newInv = {};
    for (const [key, value] of Object.entries(gameState.inventory)) {
        const newName = ITEM_RENAME_MAP[key] || key;
        newInv[newName] = (newInv[newName] || 0) + value;
    }
    gameState.inventory = newInv;
    gameState.stage_idx = getStageIndex(gameState.exp);
}


// ===================== 核心邏輯函式 (移植自 Python) =====================
// 依據所需修煉經驗計算訓練次數門檻（十分之一，向上取整，至少為 1）。
// 例如需要 10 EXP 的層級，需要 1 次訓練；需要 25 EXP 的層級，需要 3 次訓練。
function getRequiredTrainingsForExp(needExp) {
    // needExp 可能為 undefined 或 0，皆返回 1
    if (!needExp || needExp <= 0) return 1;
    return Math.max(1, Math.ceil(needExp / 10));
}

function getStageIndex(exp) {
    // 根據經驗與訓練次數門檻判斷玩家當前修為層級。
    // 必須同時滿足經驗值與訓練次數條件才可進入下一層。
    let idx = 0;
    for (let i = 0; i < CULTIVATION_STAGES.length; i++) {
        const [need_exp] = CULTIVATION_STAGES[i];
        const requiredTrain = getRequiredTrainingsForExp(need_exp);
        if (exp >= need_exp && gameState.total >= requiredTrain) {
            idx = i;
        } else {
            break;
        }
    }
    return idx;
}

function getCultivationStage(exp) {
    return CULTIVATION_STAGES[getStageIndex(exp)][2];
}

function getNextCultivationInfo(exp) {
    // 根據經驗值與總訓練次數，計算距離下一層所需的經驗與訓練次數
    for (const [need_exp,, name] of CULTIVATION_STAGES) {
        const requiredTrain = getRequiredTrainingsForExp(need_exp);
        if (exp < need_exp || gameState.total < requiredTrain) {
            return {
                next_stage: name,
                exp_needed: Math.max(0, need_exp - exp),
                train_needed: Math.max(0, requiredTrain - gameState.total)
            };
        }
    }
    return null;
}

function getCultivationBonusExp(score, requiredScore) {
    const diff = score - requiredScore;
    if (diff < 5) return [0, ""];
    const capped = Math.min(diff, 95);
    const n = Math.floor(capped / 5);
    const exp = Math.pow(2, n - 1);
    return [Math.floor(exp), `分數超過門檻 ${capped} 分，獲得額外 +${Math.floor(exp)} 修煉經驗！`];
}

function getItemSortKey(itemName) {
    let itemType = '未知', itemGrade = '未知';
    for (const t of ITEM_TYPE_ORDER) {
        if (t === '兵器') {
            if (itemName.includes('劍') || itemName.includes('刀') || itemName.includes('槍')) {
                itemType = t; break;
            }
        } else if (itemName.includes(t)) {
            itemType = t; break;
        }
    }
    for (const g of GRADE_NAMES) {
        if (itemName.includes(g)) {
            itemGrade = g; break;
        }
    }
    const typeIndex = ITEM_TYPE_ORDER.includes(itemType) ? ITEM_TYPE_ORDER.indexOf(itemType) : ITEM_TYPE_ORDER.length;
    const gradeIndex = GRADE_NAMES.includes(itemGrade) ? GRADE_NAMES.indexOf(itemGrade) : GRADE_NAMES.length;
    return [typeIndex, gradeIndex, itemName];
}
// 比較道具名稱的函式：依照類型索引、品階索引、最後以名稱（字典序）排序。
// 與 8-8 版 Python get_item_sort_key 配合，避免使用 join 比對造成排序錯亂。
function compareItemNames(nameA, nameB) {
    const keyA = getItemSortKey(nameA);
    const keyB = getItemSortKey(nameB);
    // 先比類型
    if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
    // 再比品階
    if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
    // 最後比名稱
    return nameA.localeCompare(nameB, 'zh-Hant');
}

function getGradeByDifficulty(difficulty) {
    const idx = Math.max(0, Math.min(GRADE_NAMES.length - 1, difficulty - 1));
    return GRADE_NAMES[idx];
}


// ===================== 遊戲流程控制 =====================
const app = document.getElementById('app');
let temporaryMessages = []; // 用於顯示臨時訊息，例如每日獎勵

function clearApp() {
    app.innerHTML = '';
    Object.values(timers).forEach(timer => clearTimeout(timer));
}

function addTemporaryMessage(html, type) {
    temporaryMessages.push({ html, type });
}

function showTemporaryMessages() {
    temporaryMessages.forEach(({html, type}) => {
        const p = document.createElement('p');
        p.className = `message ${type}`;
        p.innerHTML = html;
        app.appendChild(p);
    });
    temporaryMessages = [];
}

function handleLevelUp(prevExp, newExp) {
    const prevIdx = getStageIndex(prevExp);
    const newIdx = getStageIndex(newExp);
    if (newIdx <= prevIdx) {
        gameState.stage_idx = newIdx;
        saveGameState();
        return "";
    }
    
    let ticketsGain = 0;
    for (let k = prevIdx + 1; k <= newIdx; k++) {
        const prevName = CULTIVATION_STAGES[k - 1][2];
        const match = prevName.match(/(\d+)層$/);
        ticketsGain += match ? parseInt(match[1], 10) : 1;
    }
    
    const stonesGain = newIdx - prevIdx;
    
    gameState.stage_idx = newIdx;
    gameState.luck_tickets += ticketsGain;
    gameState.luck_tickets_total += ticketsGain;
    gameState.stones += stonesGain;
    saveGameState();

    // 播放升級音效
    try {
        if (typeof playLevelUp === 'function') {
            playLevelUp();
        }
    } catch (e) {}
    
    let parts = [];
    if (ticketsGain > 0) parts.push(`+${ticketsGain} 票`);
    if (stonesGain > 0) parts.push(`+${stonesGain} 靈石`);

    return `🎟️ 升層獎勵：${parts.join('、')}（目前票 ${gameState.luck_tickets}，靈石 ${gameState.stones}）`;
}

function grantDailyTicketIfNeeded() {
    // 使用本地時間
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString().split('T')[0];

    if (gameState.last_daily_ticket_date !== today) {
        gameState.luck_tickets += 1;
        gameState.luck_tickets_total += 1;
        gameState.stones += 1;
        gameState.last_daily_ticket_date = today;
        saveGameState();
        addTemporaryMessage(`🎁 今日登入贈送 +1 測試機會及 +1 靈石（目前票 ${gameState.luck_tickets}，靈石 ${gameState.stones}）`, 'msg-daily');
    }
}

// ===================== 主選單渲染 =====================
function renderMainMenu() {
    clearApp();
    grantDailyTicketIfNeeded();
    
    const highestScore = Object.keys(maxScores).length > 0 ? Math.max(...Object.values(maxScores)) : 0;
    const currentStage = getCultivationStage(gameState.exp);
    const nextInfo = getNextCultivationInfo(gameState.exp);
    
    let nextStageProgress = 100;
    let progressTip = "🌟 你已達到最終修為！";

    if (nextInfo) {
        progressTip = `⬆️ 距離「${nextInfo.next_stage}」還差 ${nextInfo.exp_needed} 修煉經驗、訓練 ${nextInfo.train_needed} 次`;
        let prevNeed = 0;
        for (const [need_exp] of CULTIVATION_STAGES) {
            if (gameState.exp >= need_exp) prevNeed = need_exp;
            else break;
        }
        let nextNeed = CULTIVATION_STAGES.find(([need_exp]) => gameState.exp < need_exp)?.[0];
        if (nextNeed !== undefined) {
            const span = Math.max(1, nextNeed - prevNeed);
            nextStageProgress = Math.floor((gameState.exp - prevNeed) * 100 / span);
        }
    }
    
    let html = `
        <h1>🎯 運氣訓練工具</h1>
        <h2>V9-0（修仙網頁版）</h2>
        <p style="text-align:center;">請選擇訓練難度（1 最簡單～10 最困難）</p>
    `;

    for (let i = 1; i <= 10; i++) {
        const score = maxScores[i] || 0;
        html += `<button data-action="start-training" data-level="${i}">難度 ${i}（最高分：${score}） 勝率：約 ${DIFFICULTY_WIN_RATE[i]}%</button>`;
    }

    html += `
        <div class="info-section">
            <p style="font-size: 1.2em; color: var(--teal-color);">🧘‍♂️ 目前修為：${currentStage}</p>
            <p style="font-size: 1.2em; color: var(--gold-color);">🎖️ 目前仙門位階：${gameState.current_title}</p>
            <p style="font-size: 0.9em; color: var(--secondary-color);">${progressTip}</p>
            <progress value="${nextStageProgress}" max="100"></progress>
            <p>🏋️ 累積訓練次數：${gameState.total} | ⚔️ 修煉經驗：${gameState.exp} | ⭐ 最高分：${highestScore}</p>
            <p>🎟️ 測試機會：${gameState.luck_tickets} 次 (累積獲得：${gameState.luck_tickets_total})</p>
            <p>💎 靈石：${gameState.stones}</p>
        </div>
        <button data-action="show-stage-list">📜 查看修仙等級一覽</button>
        <button data-action="show-game-rules">📖 遊戲規則說明</button>
        <button data-action="show-rank-list">👑 查看仙門位階封號</button>
        <button data-action="show-backpack">🎒 背包</button>
        <button data-action="show-shop">🛒 商店</button>
        <button data-action="render-test-luck-menu">🔍 測試運氣</button>
        <button data-action="test-sfx">🔊 測試音效</button>
        <button class="btn-secondary" data-action="exchange-stones" data-count="1">🪙 兌換 1 靈石 (-${STONE_EXCHANGE_COST} EXP)</button>
        <hr>
        <button class="btn-warning" data-action="reset-stats">歸零訓練/經驗統計</button>
        <button class="btn-danger" data-action="clear-scores">🗑️ 清除所有最高分紀錄</button>
    `;
    
    app.innerHTML = html;
    showTemporaryMessages();
    // 修補行動裝置箭頭圖示（用 SVG 替換）
    if (typeof patchLuckArrows === 'function') {
        try { patchLuckArrows(); } catch (e) {}
    }
}

// ===================== 訓練流程 =====================

function startTraining(level) {
    trainingState = {
        difficulty: level,
        round: 0,
        success: 0,
        fail: 0,
        totalRounds: 20,
        hasAnswered: false,
        correctAnswers: [],
        gameGridButtons: [],
        // Per-round state
        hasUsedSingleUseItem: false,
        allowedChoices: 1,
        selectedChoices: [],
    };
    trainingNext();
}

function trainingNext() {
    if (trainingState.round >= trainingState.totalRounds) {
        timers.nextRound = setTimeout(showTrainingResult, 400);
        return;
    }
    trainingState.round++;
    
    // 重置每題狀態
    trainingState.hasAnswered = false;
    trainingState.hasUsedSingleUseItem = false;
    trainingState.allowedChoices = 1;
    trainingState.selectedChoices = [];
    // 本題額外時間重置
    trainingState.roundExtraTime = 0;
    // 重置倒數用的剩餘時間 (避免延續到下一題)
    trainingState.countdownRemaining = null;

    const gameDef = ALL_GAMES[Math.floor(Math.random() * ALL_GAMES.length)];
    const gameFunc = window[gameDef.func];
    gameFunc(); // This function will call renderTrainingScreen
}

function updateGameInfo() {
    const infoLabel = document.getElementById('game-info-label');
    if (infoLabel) {
        infoLabel.innerHTML = `第 ${trainingState.round}/${trainingState.totalRounds} 題 | ✅ 正確: ${trainingState.success} ❌ 錯誤: ${trainingState.fail} | 可選次數: ${trainingState.allowedChoices - trainingState.selectedChoices.length}`;
    }
}

function renderTrainingScreen(title, items, correctAnswers, columns=5, btnSize=60) {
    clearApp();
    trainingState.correctAnswers = correctAnswers;
    
    let gridTemplateColumns = `repeat(${columns}, 1fr)`;

    let buttonsHTML = '';
    items.forEach((item) => {
        // Use data-choice to avoid issues with special characters in IDs
        buttonsHTML += `<button class="grid-btn" data-action="grid-btn" data-choice="${item}" style="height:${btnSize}px;">${item}</button>`;
    });

    app.innerHTML = `
        <p id="difficulty-info-label" style="text-align:center;"></p>
        <p id="game-info-label" style="text-align:center;"></p>
        <h3 style="text-align:center;">${title} (${correctAnswers.length} 個)</h3>
        <p id="feedback-label" class="feedback"></p>
        <p id="countdown-label" style="text-align:center; color:grey;"></p>
        <div class="game-grid" style="grid-template-columns: ${gridTemplateColumns};">
            ${buttonsHTML}
        </div>
        <div id="action-buttons">
            <button data-action="show-use-item-dialog">🎒 使用道具</button>
        </div>
    `;

    updateGameInfo();
    trainingState.gameGridButtons = Array.from(document.querySelectorAll('.grid-btn'));
    startAnswerCountdown(10);

    // 更新難度與下一階段門檻資訊
    const diffLabel = document.getElementById('difficulty-info-label');
    if (diffLabel) {
        const difficulty = trainingState.difficulty || 1;
        const nextInfoStage = getNextCultivationInfo(gameState.exp);
        if (nextInfoStage) {
            diffLabel.innerHTML = `難度 ${difficulty}｜下一階段「${nextInfoStage.next_stage}」門檻：還差 ${nextInfoStage.exp_needed} 修煉經驗、訓練 ${nextInfoStage.train_needed} 次`;
        } else {
            diffLabel.innerHTML = `難度 ${difficulty}｜已達最高階段`;
        }
    }
}

function onGridButtonClick(button) {
    if (trainingState.hasAnswered) return;

    if (trainingState.allowedChoices > 1) {
        const choice = button.dataset.choice;
        button.classList.toggle('checked');
        if (button.classList.contains('checked')) {
            if (trainingState.selectedChoices.length < trainingState.allowedChoices) {
                trainingState.selectedChoices.push(choice);
            } else {
                button.classList.remove('checked'); // Exceeded choices
            }
        } else {
            trainingState.selectedChoices = trainingState.selectedChoices.filter(c => c !== choice);
        }
        updateGameInfo();
        // 不再用「選滿就自動結束」，改由按下確認或倒數結束後作答
    } else {
        checkAnswerSingle(button.dataset.choice);
    }
}

function startAnswerCountdown(seconds) {
    // 本題倒數時間：基礎秒數 + roundExtraTime（上一題加時已在 trainingNext() 重置）
    let remaining = seconds + (trainingState.roundExtraTime || 0);
    // 使用 state 儲存剩餘秒數，方便在使用陣法時即時增加
    trainingState.countdownRemaining = remaining;
    const countdownLabel = document.getElementById('countdown-label');
    
    if (timers.answer) clearTimeout(timers.answer);

    const update = () => {
        // 若 UI 被切換就停止計時
        if (!document.getElementById('countdown-label')) return;
        // 若已回答則停表
        if (trainingState.hasAnswered) {
            countdownLabel.textContent = "作答結束";
            return;
        }
        // 以 state 中的剩餘秒數為準（可能被陣法中途加時修改）
        remaining = trainingState.countdownRemaining || 0;
        if (remaining >= 0) {
            countdownLabel.textContent = `作答倒數：${remaining} 秒`;
            trainingState.countdownRemaining = remaining - 1;
            timers.answer = setTimeout(update, 1000);
        } else {
            countdownLabel.textContent = "時間到！";
            if (trainingState.allowedChoices > 1) {
                checkAnswerMulti();
            } else {
                checkAnswerSingle(null); // null means timeout
            }
        }
    };
    update();
}

function checkAnswerSingle(choice) {
    if (trainingState.hasAnswered) return;
    trainingState.hasAnswered = true;
    
    const feedbackLabel = document.getElementById('feedback-label');
    let correct = false;

    if (choice === null) { // Timeout
        trainingState.fail++;
        feedbackLabel.innerHTML = `❌ 時間到！正確答案：${trainingState.correctAnswers.join(', ')}`;
        feedbackLabel.className = "feedback error";
    } else {
        correct = trainingState.correctAnswers.includes(choice);
        if (correct) {
            trainingState.success++;
            feedbackLabel.innerHTML = `✅ 恭喜你選對了！你選的是：${choice}`;
            feedbackLabel.className = "feedback success";
        } else {
            trainingState.fail++;
            feedbackLabel.innerHTML = `❌ 錯了，你選的是：${choice} 正確答案：${trainingState.correctAnswers.join(', ')}`;
            feedbackLabel.className = "feedback error";
        }
        // Query selector needs to handle special characters in data attributes
        document.querySelector(`.grid-btn[data-choice="${choice}"]`).classList.add('selected');
    }
    
    finalizeRound();
}

function checkAnswerMulti() {
    if (trainingState.hasAnswered) return;
    trainingState.hasAnswered = true;
    
    document.getElementById('confirm-btn')?.remove();

    const feedbackLabel = document.getElementById('feedback-label');
    const isCorrect = trainingState.selectedChoices.some(c => trainingState.correctAnswers.includes(c));

    if (isCorrect) {
        trainingState.success++;
        feedbackLabel.innerHTML = `✅ 答對了！你的選擇中包含了正確答案。`;
        feedbackLabel.className = "feedback success";
    } else {
        trainingState.fail++;
        feedbackLabel.innerHTML = `❌ 答錯了！正確答案是：${trainingState.correctAnswers.join(', ')}`;
        feedbackLabel.className = "feedback error";
    }
    finalizeRound();
}

function finalizeRound() {
    updateGameInfo();
    // 結算回合後清除本題加時，避免延續到下一題（雙重保障）
    trainingState.roundExtraTime = 0;
    // 清除倒數剩餘時間狀態
    trainingState.countdownRemaining = null;
    if (timers.nextRound) clearTimeout(timers.nextRound);
    timers.nextRound = setTimeout(trainingNext, 2000);
}

function enterMultiChoiceMode() {
    if (trainingState.allowedChoices <= 1) return;
    if (document.getElementById('confirm-btn')) return;

    const confirmBtn = document.createElement('button');
    confirmBtn.id = 'confirm-btn';
    confirmBtn.textContent = '確認選擇';
    confirmBtn.dataset.action = "check-answer-multi";
    document.getElementById('action-buttons').appendChild(confirmBtn);
}


function showTrainingResult() {
    clearApp();
    const score = Math.floor((trainingState.success / trainingState.totalRounds) * 100);
    const prevTotalTrainCount = gameState.total;
    gameState.total++;

    if (score > (maxScores[trainingState.difficulty] || 0)) {
        maxScores[trainingState.difficulty] = score;
    }
    
    const required = DIFFICULTY_WIN_RATE[trainingState.difficulty] || 0;
    const [bonusExp, bonusMsg] = getCultivationBonusExp(score, required);
    const prevExp = gameState.exp;
    const baseExp = 1;
    const totalGain = baseExp + Math.max(0, bonusExp);
    gameState.exp += totalGain;
    if (bonusExp > 0) gameState.bonus = (gameState.bonus || 0) + bonusExp;

    // === 新增處罰機制 ===
    // 若得分低於該難度的勝率門檻，依差距扣減修煉值
    let penaltyMsg = "";
    if (score < required) {
        const diffLow = required - score;
        if (diffLow >= 5) {
            const steps = Math.floor(diffLow / 5);
            const penaltyPercent = Math.pow(2, steps - 1);
            let penaltyExp = Math.floor(gameState.exp * penaltyPercent / 100);
            if (penaltyExp > 0) {
                gameState.exp = Math.max(0, gameState.exp - penaltyExp);
                penaltyMsg = `❌ 分數低於門檻 ${diffLow} 分，扣除 ${penaltyExp} 修煉值 (${penaltyPercent}%)`;
            }
        }
    }

    // 在扣除處罰後進行升級判定
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    
    let resultHTML = `
        <h2>🏁 訓練完成</h2>
        <div class="feedback success">得分：${score} / 100</div>
        <p style="text-align:center;">💡 基本修煉經驗 +${baseExp}</p>
    `;
    if (bonusMsg) resultHTML += `<p style="text-align:center; color:green;">🎉 ${bonusMsg}</p>`;
    if (penaltyMsg) resultHTML += `<p style="text-align:center; color:red;">${penaltyMsg}</p>`;
    if (levelupMsg) resultHTML += `<p class="message msg-levelup">${levelupMsg}</p>`;

    let rewardsHTML = '';
    
    // 週期獎勵
    if (gameState.total > 0 && gameState.total % 5 === 0) {
        const [rewardsList] = grantRandomRewards(1);
        rewardsHTML += `<div class="message msg-reward">🎉 累積訓練達 ${gameState.total} 次，達成週期獎勵！<br>${rewardsList.join('<br>')}</div>`;
    }
    
    // 里程碑獎勵
    if (TRAINING_MILESTONES[gameState.total]) {
        const milestone = TRAINING_MILESTONES[gameState.total];
        gameState.current_title = milestone.title;
        const [rewardsList] = grantRandomRewards(milestone.rewards);
        rewardsHTML += `<div class="message msg-reward">🏆 恭喜！訓練達 ${gameState.total} 次，達成里程碑！<br>獲得新位階：【${milestone.title}】<br>獲得獎勵：<br>${rewardsList.join('<br>')}</div>`;
    }

    // 特定次數獎勵
    const countRewards = checkTrainingCountRewards(prevTotalTrainCount, gameState.total);
    if (countRewards) rewardsHTML += `<div class="message msg-reward">${countRewards}</div>`;

    // 靈石獎勵
    let stonesAward = 0;
    if (score >= 90) stonesAward = 3;
    else if (score >= 70) stonesAward = 2;
    else if (score >= 50) stonesAward = 1;
    if (score === 100) stonesAward += 3;
    const randomDrop = Math.random() < 0.10 ? 1 : 0;
    const totalStonesGain = stonesAward + randomDrop;
    if (totalStonesGain > 0) {
        gameState.stones += totalStonesGain;
        let parts = [];
        if (stonesAward > 0) parts.push(`根據表現獲得 ${stonesAward} 靈石`);
        if (randomDrop > 0) parts.push("偶遇驚喜：+1 靈石");
        rewardsHTML += `<p style="text-align:center; color:darkorchid">💎 ${parts.join('；')}</p>`;
    }

    saveGameState();
    // 更新主畫面資訊，以反映處罰與獎勵
    if (typeof updateMainMenuInfo === 'function') {
        try { updateMainMenuInfo(); } catch (e) {}
    }
    
    const comment = commentForScore(score, required);

    resultHTML += rewardsHTML;
    resultHTML += `<p style="text-align:center; color:purple; font-style:italic;">"${comment}"</p>`;
    resultHTML += `<button data-action="render-main-menu">🔁 回主選單</button>`;
    app.innerHTML = resultHTML;
}

function checkTrainingCountRewards(prev, current) {
    let msg = [];
    const addItem = (itemName) => {
        gameState.inventory[itemName] = (gameState.inventory[itemName] || 0) + 1;
        if (!gameState.inventory_order.includes(itemName)) {
            gameState.inventory_order.push(itemName);
            gameState.inventory_order.sort((a, b) => {
                const keyA = getItemSortKey(a);
                const keyB = getItemSortKey(b);
                if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
                if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
                return a.localeCompare(b, 'zh-Hant');
            });
        }
    };

    if (prev < 100 && current >= 100) {
        const item = Math.random() < 0.5 ? "入品三才聚靈陣" : "入品四門陷敵陣";
        addItem(item);
        msg.push(`🎁 百煉成鋼！訓練達 100 次，領悟陣法：【${item}】`);
    }
    if (prev < 200 && current >= 200) {
        const item = Math.random() < 0.5 ? "入品築基吐納訣" : "入品松鹤長青功";
        addItem(item);
        msg.push(`🎁 道心穩固！訓練達 200 次，習得功法：【${item}】`);
    }
    if (prev < 500 && current >= 500) {
        const item = ["入品青竹劍", "入品銅背刀", "入品碎雲槍"][Math.floor(Math.random() * 3)];
        addItem(item);
        msg.push(`🎁 鋒芒初露！訓練達 500 次，獲得兵器：【${item}】`);
    }
    return msg.join('<br>');
}

function commentForScore(score, expected) {
    const diff = score - expected;
    const feedbacks = {
        95:"運氣超神，無人能敵！", 90:"運氣神化，無人能敵！", 85:"運氣爆棚，羨煞眾人！", 80:"天選之人，非你莫屬！", 75:"絕對的運氣掌握者！", 70:"運勢如虹，無人能擋。", 65:"強運來襲，勢不可擋。", 60:"你的運勢如日中天。", 55:"幸運星高照，前途似錦。", 50:"好運連連，勢頭正旺。", 45:"略勝一籌，前景可期。", 40:"實力與運氣兼具。", 35:"穩紮穩打，逐步晉升。", 30:"運氣尚佳，可再接再厲。", 25:"略高一線，尚有進步空間。", 20:"勉強超標，繼續努力。", 15:"稍稍領先，還需拼搏。", 10:"剛剛好過線，別鬆懈。", 5:"險中求勝，驚險過關。", 0:"中規中矩，剛好符合預期。",
        [-5]:"些微落後，調整心態。",[-10]:"差強人意，還需努力。",[-15]:"小有失利，穩住陣腳。", [-20]:"略低於平均，再接再厲。",[-25]:"運勢偏弱，繼續挑戰。",[-30]:"表現平平，需要加強。", [-35]:"稍嫌遜色，不如預期。",[-40]:"有點背運，振作起來。",[-45]:"運氣不濟，再戰一場。", [-50]:"明顯落後，重整旗鼓。",[-55]:"實力未展，下次再來。",[-60]:"狀況不佳，需要反思。", [-65]:"運氣低迷，注意轉運。",[-70]:"大幅失利，再接再厲。",[-75]:"今日不宜出門…", [-80]:"諸事不順，忍耐為上。",[-85]:"背運纏身，請小心行事。",[-90]:"極度背運，快去求神問卜。"
    };
    const closest = Object.keys(feedbacks).reduce((prev, curr) => Math.abs(curr - diff) < Math.abs(prev - diff) ? curr : prev);
    return feedbacks[closest] || "運勢未知，保持平常心。";
}


// ===================== 遊戲題庫生成 =====================
// ▼▼▼ MAJOR FIX: Corrected the logic to ensure answer positions are truly random. ▼▼▼
function game_template(title, pool, total, columns=5, btnSize=60) {
    // 1. 從題庫中隨機選出本次要顯示的所有選項
    const itemsForDisplay = [...pool].sort(() => 0.5 - Math.random()).slice(0, total);

    // 2. 決定正確答案的數量
    const correctCount = generateCorrectChoices(total);

    // 3. 從剛剛選出的選項中，**再次隨機挑選**出正確答案
    //    這是修正的核心，確保正確答案不是固定在前幾個
    const correctAnswers = [...itemsForDisplay].sort(() => 0.5 - Math.random()).slice(0, correctCount);

    // 4. 將隨機排列的選項和隨機選定的答案傳遞給渲染函式
    renderTrainingScreen(title, itemsForDisplay, correctAnswers, columns, btnSize);
}

function generateCorrectChoices(total) {
    const ratio = 1 - (trainingState.difficulty / 10);
    let correctCount = Math.max(1, Math.floor(total * ratio));
    if (trainingState.difficulty === 1 && correctCount === total) {
        correctCount--;
    }
    return correctCount;
}

// Assign game functions to the window object so they can be called by string name
window.game_guess_hidden = () => { const n = 10; game_template("從 1～10 選出正確號碼", Array.from({length: n}, (_, i) => String(i + 1)), n, 5); }
window.game_guess_20 = () => { const n = 20; game_template("從 1～20 選出正確號碼", Array.from({length: n}, (_, i) => String(i + 1)), n, 5); }
window.game_guess_30 = () => { const n = 30; game_template("從 1～30 選出正確號碼", Array.from({length: n}, (_, i) => String(i + 1)), n, 6); }
window.game_treasure_box = () => { const n = [10, 20, 30][Math.floor(Math.random()*3)]; game_template("寶箱訓練", Array.from({length: n}, (_, i) => String(i + 1)), n, n > 20 ? 6 : 5); }
window.game_gift_box = () => { const n = [10, 20, 30][Math.floor(Math.random()*3)]; game_template("禮物訓練", Array.from({length: n}, (_, i) => String(i + 1)), n, n > 20 ? 6 : 5); }
window.game_emoji_pick = () => { game_template("選出好運表情符號", EMOJIS, EMOJIS.length, 5); }
window.game_animals = () => { game_template("選出幸運動物", ANIMALS, ANIMALS.length, 5); }
window.game_foods = () => { game_template("選出幸運食物", FOODS, FOODS.length, 5); }
window.game_places = () => { game_template("選出幸運地點", PLACES, PLACES.length, 5); }
window.game_shape_select = () => { game_template("選出幸運圖形", SHAPES, SHAPES.length, 5); }
window.game_color_select = () => { game_template("找出幸運顏色", COLORS, COLORS.length, 5); }
window.game_flags = () => { game_template("選出幸運國旗", FLAGS, FLAGS.length, 5); }
window.game_nature = () => { game_template("選出幸運自然現象", NATURE, NATURE.length, 5); }
window.game_cards = () => { game_template("選出幸運撲克牌", CARDS, CARDS.length, 10, 48); }
window.game_mahjong = () => { game_template("選出幸運麻將", MAHJONG, MAHJONG.length, 7); }
window.game_vehicles = () => { game_template("選出幸運交通工具", VEHICLES, VEHICLES.length, 6); }
window.game_zodiacs = () => { game_template("選出幸運星座", ZODIACS, ZODIACS.length, 6); }
window.game_lucky_period = () => { game_template("挑選幸運時段", CLOCKS, CLOCKS.length, 6, 48); }
window.game_professions = () => { game_template("選出幸運職業", PROFESSIONS, PROFESSIONS.length, 7, 56); }
window.game_sports = () => { game_template("挑選運動與獎項", SPORTS, SPORTS.length, 6, 48); }
window.game_office = () => { game_template("挑選辦公文具", OFFICE, OFFICE.length, 6, 48); }
window.game_tools = () => { game_template("挑選工具、家居用品及其他", TOOLS, TOOLS.length, 6, 48); }

// 新增三種圖示訓練函式
// 自動拆分後的四個題庫函式
window.game_office_a = () => { game_template("選出辦公文具A", OFFICE_A, OFFICE_A.length, 6, 48); };
window.game_office_b = () => { game_template("選出辦公文具B", OFFICE_B, OFFICE_B.length, 6, 48); };
window.game_tools_a = () => { game_template("選出工具、家居用品及其他A", TOOLS_A, TOOLS_A.length, 6, 48); };
window.game_tools_b = () => { game_template("選出工具、家居用品及其他B", TOOLS_B, TOOLS_B.length, 6, 48); };

window.game_sports_awards = () => { game_template("選出體育與獎項", SPORTS, SPORTS.length, 6, 48); };
window.game_office_supplies = () => { game_template("選出辦公文具", OFFICE, OFFICE.length, 6, 48); };
window.game_tools_others = () => { game_template("選出工具、家居用品及其他", TOOLS, TOOLS.length, 6, 48); };


// ===================== 測試運氣系統 =====================

function renderTestLuckMenu() {
    clearApp();
    grantDailyTicketIfNeeded();
    const tickets = gameState.luck_tickets;
    app.innerHTML = `
        <h2>🧪 測試你的運氣</h2>
        <div class="info-section" style="padding:10px;">
            <p>抽卡模式將隨機獲得修煉經驗、靈石、票券或道具。</p>
            <p>🎟️ 目前測試機會：${tickets} 次</p>
            <p>📅 今日運勢不消耗票。</p>
        </div>
        <button data-action="run-luck-draw" data-draws="1" data-mode="幸運抽卡單抽" ${tickets < 1 ? 'disabled' : ''}>🃏 單抽 (消耗 1 票)</button>
        <button data-action="run-luck-draw" data-draws="3" data-mode="幸運抽卡三抽" ${tickets < 3 ? 'disabled' : ''}>🃏 三抽 (消耗 3 票)</button>
        <button data-action="run-luck-draw" data-draws="10" data-mode="幸運抽卡10連抽" ${tickets < 10 ? 'disabled' : ''}>🃏 十連抽 (消耗 10 票)</button>
        <button data-action="run-luck-draw" data-draws="100" data-mode="幸運抽卡100連抽" ${tickets < 100 ? 'disabled' : ''}>🃏 百連抽 (消耗 100 票)</button>
        <button data-action="run-luck-draw" data-draws="1000" data-mode="幸運抽卡1000連抽" ${tickets < 1000 ? 'disabled' : ''}>🃏 千連抽 (消耗 1000 票)</button>
        <button data-action="run-luck-draw" data-draws="${tickets}" data-mode="幸運抽卡全部抽" ${tickets < 1 ? 'disabled' : ''}>🃏 全部抽 (消耗 ${tickets} 票)</button>
        <button data-action="run-today-luck">📅 今日運勢 (每日一次｜免費)</button>
        <hr>
        <button class="btn-secondary" data-action="redeem-tickets" data-pieces="1" data-cost="${REDEEM_1_COST}">🎫 兌換 1 張 (-${REDEEM_1_COST} EXP)</button>
        <button class="btn-secondary" data-action="redeem-tickets" data-pieces="5" data-cost="${REDEEM_5_COST}">🎫 兌換 5 張 (-${REDEEM_5_COST} EXP)</button>
        <hr>
        <button data-action="show-luck-history">📈 查看歷史與統計</button>
        <button data-action="render-main-menu">🔙 返回主選單</button>
    `;
    showTemporaryMessages();
    // 對行動裝置修補箭頭圖示
    if (typeof patchLuckArrows === 'function') {
        try { patchLuckArrows(); } catch (e) {}
    }
}

function redeemTickets(pieces, cost) {
    if (gameState.exp < cost) {
        addTemporaryMessage(`⚠️ EXP 不足 (需要 ${cost}，目前 ${gameState.exp})`, 'msg-shop-fail');
    } else {
        gameState.exp -= cost;
        gameState.luck_tickets += pieces;
        gameState.luck_tickets_total += pieces;
        addTemporaryMessage(`✅ 兌換成功：-${cost} EXP → +${pieces} 票`, 'msg-shop');
        saveGameState();
    }
    renderTestLuckMenu();
}

function runLuckDraw(draws, mode) {
    if (gameState.luck_tickets < draws || draws <= 0) {
        addTemporaryMessage(`⚠️ 測試機會不足！`, 'msg-shop-fail');
        renderTestLuckMenu();
        return;
    }
    gameState.luck_tickets -= draws;
    
    const [details, totals] = grantRandomRewards(draws);
    
    let summaryParts = [];
    if (totals.exp > 0) summaryParts.push(`+${totals.exp} EXP`);
    if (totals.stones > 0) summaryParts.push(`+${totals.stones} 靈石`);
    if (totals.tickets > 0) summaryParts.push(`+${totals.tickets} 票券`);
    if (Object.keys(totals.items).length > 0) {
        const totalItems = Object.values(totals.items).reduce((a, b) => a + b, 0);
        summaryParts.push(`+${totalItems} 件道具`);
    }

    const summaryMsg = summaryParts.length > 0 ? summaryParts.join('、') : "什麼都沒有...";
    addLuckHistory(mode, 0, "", totals.exp, summaryMsg);
    
    renderDrawResult(summaryMsg, details, mode, draws);
}

function addLuckHistory(mode, value, category, expGain, rewardMsg) {
    gameState.luck_tests_total++;
    gameState.luck_history.push({
        time: new Date().toLocaleString('sv-SE'), // YYYY-MM-DD HH:MM:SS
        mode, value, category, exp: expGain, reward_msg: rewardMsg
    });
    if (gameState.luck_history.length > 200) {
        gameState.luck_history.shift();
    }
    saveGameState();
}

function grantRandomRewards(count) {
    let rewardsList = [], totals = { exp: 0, stones: 0, tickets: 0, items: {} };
    
    const itemPool = Object.keys(ITEM_STONE_PRICES);
    const weights = itemPool.map(item => {
        const price = ITEM_STONE_PRICES[item] || 1;
        const grade = GRADE_NAMES.findIndex(g => item.startsWith(g)) + 1 || 1;
        return 1000 / (price * grade + 1);
    });

    const getScaledRandomAmount = (min, max) => {
        const bias_factor = Math.pow(gameState.stage_idx / CULTIVATION_STAGES.length, 2);
        const mode = min + (max - min) * bias_factor;
        const u = Math.random();
        // triangular distribution formula
        return Math.ceil(u < (mode - min) / (max - min) ? min + Math.sqrt(u * (max - min) * (mode - min)) : max - Math.sqrt((1 - u) * (max - min) * (max - mode)));
    };

    for (let i = 0; i < count; i++) {
        const rand = Math.random() * 100;
        let rewardType;
        if (rand < 40) rewardType = "exp";
        else if (rand < 70) rewardType = "stones";
        else if (rand < 85) rewardType = "tickets";
        else rewardType = "item";

        if (rewardType === 'exp') {
            const amount = getScaledRandomAmount(1, 1000);
            totals.exp += amount;
            rewardsList.push(`獲得 修煉經驗 +${amount}`);
        } else if (rewardType === 'stones') {
            const amount = getScaledRandomAmount(1, 100);
            totals.stones += amount;
            rewardsList.push(`獲得 靈石 +${amount}`);
        } else if (rewardType === 'tickets') {
            const amount = getScaledRandomAmount(1, 5);
            totals.tickets += amount;
            rewardsList.push(`獲得 票券 +${amount}`);
        } else if (rewardType === 'item') {
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let randWeight = Math.random() * totalWeight;
            let itemName = itemPool[itemPool.length - 1];
            for(let j=0; j<weights.length; j++){
                if(randWeight < weights[j]){
                    itemName = itemPool[j];
                    break;
                }
                randWeight -= weights[j];
            }
            const amount = getScaledRandomAmount(1, 10);
            totals.items[itemName] = (totals.items[itemName] || 0) + amount;
            rewardsList.push(`獲得 道具 [${itemName}] ×${amount}`);
        }
    }

    const prevExp = gameState.exp;
    gameState.exp += totals.exp;
    gameState.stones += totals.stones;
    gameState.luck_tickets += totals.tickets;
    Object.entries(totals.items).forEach(([name, qty]) => {
        gameState.inventory[name] = (gameState.inventory[name] || 0) + qty;
         if (!gameState.inventory_order.includes(name)) gameState.inventory_order.push(name);
    });
    if(Object.keys(totals.items).length > 0){
        gameState.inventory_order.sort((a,b) => compareItemNames(a,b));
    }

    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    if (levelupMsg) rewardsList.push(`<span class="msg-levelup">${levelupMsg}</span>`);
    
    saveGameState();
    return [rewardsList, totals];
}

function runTodayLuck() {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString().split('T')[0];

    if (gameState.last_luck_date === today) {
        showTodayLuckResult(true);
        return;
    }

    const [rewardsList, totals] = grantRandomRewards(1);
    const rewardMsg = rewardsList[0] || "今日平淡無奇...";

    gameState.last_luck_date = today;
    gameState.last_luck_reward_msg = rewardMsg;

    addLuckHistory("今日運勢", 0, "動態獎勵", totals.exp, rewardMsg);
    showTodayLuckResult(false);
}

function renderDrawResult(summary, details, mode, draws) {
    clearApp();
    const currentStage = getCultivationStage(gameState.exp);
    
    app.innerHTML = `
        <h2>🃏 ${mode} 結果</h2>
        <div class="feedback info">🎁 總計：${summary}</div>
        <div style="height: 150px; overflow-y:auto; border:1px solid #ccc; padding:10px; border-radius:6px; margin-bottom:15px;">
            ${details.join('<br>')}
        </div>
        <div class="info-section" style="padding:10px;">
            <p style="font-size: 1.1em; color: var(--teal-color);">🧘‍♂️ 目前修為：${currentStage}</p>
            <p>累積 EXP：${gameState.exp}</p>
        </div>
        <button data-action="run-luck-draw" data-draws="${draws}" data-mode="${mode}" ${gameState.luck_tickets < draws ? 'disabled' : ''}>🔁 再來一次 (${draws} 票)</button>
        <button data-action="show-luck-history">📈 查看歷史與統計</button>
        <button data-action="render-test-luck-menu">🔙 返回測試選單</button>
        <button data-action="render-main-menu">🏠 回主選單</button>
    `;
}

function showTodayLuckResult(isRepeat) {
    clearApp();
    const luckySuggestion = () => {
        const seed = parseInt(new Date().toISOString().slice(0, 10).replace(/-/g, ''), 10);
        const rng = (s) => () => { s = Math.sin(s) * 10000; return s - Math.floor(s); };
        const rand = rng(seed);
        const lucky_num = Math.floor(rand() * 39) + 1;
        const lucky_color = COLORS[Math.floor(rand() * COLORS.length)];
        const lucky_emoji = EMOJIS[Math.floor(rand() * EMOJIS.length)];
        const lucky_dir = ["上", "下", "左", "右", "左上", "右上", "右下", "左下"][Math.floor(rand() * 8)];
        return `幸運號碼：${lucky_num} | 幸運色：${lucky_color} | 幸運表情：${lucky_emoji} | 幸運方位：${lucky_dir}`;
    };

    app.innerHTML = `
        <h2>📅 今日運勢</h2>
        <div class="feedback" style="color:darkorange">${isRepeat ? '(今日已測) ' : ''}${gameState.last_luck_reward_msg}</div>
        <p style="text-align:center;">${luckySuggestion()}</p>
        <div class="info-section" style="padding:10px;">
            <p style="font-size: 1.1em; color: var(--teal-color);">🧘‍♂️ 目前修為：${getCultivationStage(gameState.exp)}</p>
        </div>
        <button data-action="render-test-luck-menu">🔙 返回測試選單</button>
        <button data-action="render-main-menu">🏠 回主選單</button>
    `;
}

// ===================== 雜項功能 & 重置 =====================
function exchangeStones(count) {
    const cost = STONE_EXCHANGE_COST * count;
    if (gameState.exp < cost) {
        addTemporaryMessage(`⚠️ EXP 不足，無法兌換`, 'msg-shop-fail');
    } else {
        gameState.exp -= cost;
        gameState.stones += count;
        handleLevelUp(gameState.exp + cost, gameState.exp); // Recalculate level
        addTemporaryMessage(`✅ 兌換成功：-${cost} EXP → +${count} 靈石`, 'msg-shop');
        saveGameState();
    }
    renderMainMenu();
}

function resetTrainingStats() {
    if (confirm("確定要歸零所有訓練統計、經驗、道具和等級嗎？此操作無法復原。")) {
        gameState = JSON.parse(JSON.stringify(defaultStats));
        saveGameState();
        renderMainMenu();
    }
}

function clearMaxScores() {
    if (confirm("確定要清除所有難度的最高分紀錄嗎？此操作無法復原。")) {
        maxScores = {};
        saveGameState();
        renderMainMenu();
    }
}


// ===================== Modal (彈出視窗) 系統 =====================
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modal-title');
const modalBody = document.getElementById('modal-body');
const modalFooter = document.getElementById('modal-footer');
const modalCloseBtn = document.getElementById('modal-close-btn');

modalCloseBtn.onclick = () => modal.style.display = "none";
window.onclick = (event) => {
    if (event.target == modal) {
        modal.style.display = "none";
    }
}

function showModal(title, bodyHTML, footerHTML = '') {
    modalTitle.textContent = title;
    modalBody.innerHTML = bodyHTML;
    modalFooter.innerHTML = footerHTML;
    modal.style.display = "flex";
}

function showStageList() {
    // 列出各層級所需的修煉經驗與訓練次數門檻
    const content = CULTIVATION_STAGES.map(([exp,, name]) => {
        const requiredTrain = getRequiredTrainingsForExp(exp);
        return `<li><b>${name}</b>：需修煉經驗 ${exp}，訓練次數門檻 ${requiredTrain}</li>`;
    }).join('');
    showModal("修仙等級一覽表", `<ul style="padding-left: 20px;">${content}</ul>`, `<button data-action="close-modal">關閉</button>`);
}

function showRankList() {
    let content = '仙門位階是根據您的總訓練次數授予的榮譽稱號：<br><br><ul style="padding-left: 20px;">';
    content += Object.entries(TRAINING_MILESTONES).map(([count, data]) => `<li>訓練 <b>${count}</b> 次：授予位階【${data.title}】</li>`).join('');
    showModal("仙門位階封號一覽表", `${content}</ul>`, `<button data-action="close-modal">關閉</button>`);
}

function showLuckHistory() {
    let content = '';
    if (!gameState.luck_history || gameState.luck_history.length === 0) {
      content = "尚無歷史紀錄。";
    } else {
      const totalExp = gameState.luck_history.reduce((s, h) => s + (h.exp || 0), 0);
      content += `<p><b>累積經驗 +${totalExp}</b></p><hr>`;
      content += '<ul style="padding-left: 20px; word-break: break-all;">';
      gameState.luck_history.slice().reverse().slice(0, 50).forEach(h => {
        content += `<li>[${h.time}] <b>${h.mode}</b> → ${h.reward_msg || `${h.value} (${h.category})`} (EXP +${h.exp})</li>`;
      });
      content += '</ul>';
    }
    showModal("測試運氣歷史", content, `<button data-action="close-modal">關閉</button>`);
}

// 遊戲規則說明：詳細說明升級獎勵、關卡、道具功能以及處罰機制。
// # 新增遊戲規則說明按鈕對應的函式
function showGameRules() {
    /* # 遊戲規則：
       1. 升級獎勵說明：當你的修煉經驗與訓練次數同時達到下一層門檻，
          修為會自動突破。每突破一層，將獲得一定數量的測試機會與靈石獎勵。
       2. 遊戲關卡說明：訓練共有 10 種難度，每回合包含 20 題圖示，請在倒數時間內選出目標。答對可累積修煉經驗與訓練次數，達到該難度要求的勝率可獲得額外經驗加成。
       3. 道具升級及功能說明：道具分為兵器、功法、陣法、靈器、靈符、仙丹等類：
          - 兵器：增加可選答案數，可在多選題中使用；
          - 功法：排除部分錯誤答案；
          - 陣法：增加當題作答時間；
          - 靈器：顯示全部正確答案；
          - 靈符：顯示部分錯誤答案；
          - 仙丹：立即增加修煉經驗。
          道具可以在商店購買，或透過消耗靈石升級為更高品階，效果將更強。升級消耗的靈石會即時扣除並更新顯示。
       4. 處罰機制：若訓練結束時得分低於該難度要求的勝率門檻，將扣減修煉經驗。差距每增加 5 分，處罰率翻倍：差 5 分扣 1%，差 10 分扣 2%，差 15 分扣 4%，差 20 分扣 8%，差 25 分扣 16%，差 30 分扣 32%，以此類推。當修煉經驗為 0 時不再扣減。*/
    const content = `
        <div style="text-align:left;">
            <h3>1. 升級獎勵說明</h3>
            <p>當你的修煉經驗與訓練次數同時達到下一層門檻時，修為會自動突破。每突破一層，依據突破層級差距獲得相應數量的測試機會與靈石。</p>
            <h3>2. 遊戲關卡說明</h3>
            <p>訓練共有 10 個難度，每回合包含 20 題圖示，請在倒數時間內選出目標。答對能累積修煉經驗與訓練次數；達到該難度要求的勝率，可額外獲得修煉經驗獎勵。</p>
            <h3>3. 道具升級及功能說明</h3>
            <p>道具分為兵器、功法、陣法、靈器、靈符、仙丹等類，每種道具功能如下：</p>
            <ul>
                <li><b>兵器</b>：增加可選答案數，可用於多選題。</li>
                <li><b>功法</b>：排除部分錯誤答案。</li>
                <li><b>陣法</b>：增加作答時間，僅對當題有效。</li>
                <li><b>靈器</b>：顯示全部正確答案。</li>
                <li><b>靈符</b>：顯示部分錯誤答案。</li>
                <li><b>仙丹</b>：立即增加修煉經驗。</li>
            </ul>
            <p>道具可在商店購買，或使用靈石進行升級以提升效果。升級時消耗的靈石會即刻從你的帳戶扣除並刷新主畫面。</p>
            <h3>4. 處罰機制</h3>
            <p>若訓練結算得分低於該難度要求的勝率門檻，你的修煉經驗將被扣減。與門檻差距每增加 5 分，處罰率翻倍：差 5 分扣 1%，差 10 分扣 2%，差 15 分扣 4%，差 20 分扣 8%，差 25 分扣 16%，差 30 分扣 32%，依此類推。當修煉經驗為 0 時不再扣減。</p>
        </div>
    `;
    showModal("📜 遊戲規則說明", content, `<button data-action="close-modal">關閉</button>`);
}

// 更新主選單資料，例如修煉經驗、靈石與訓練次數等。
// # 當消耗或增加修煉經驗/靈石後，可調用此函式即時更新主選單顯示。
function updateMainMenuInfo() {
    const info = document.querySelector('.info-section');
    if (!info) return;
    const highestScore = Object.keys(maxScores).length > 0 ? Math.max(...Object.values(maxScores)) : 0;
    const currentStage = getCultivationStage(gameState.exp);
    const nextInfo = getNextCultivationInfo(gameState.exp);
    const ps = info.querySelectorAll('p');
    if (ps[0]) ps[0].innerHTML = `🧘‍♂️ 目前修為：${currentStage}`;
    if (ps[1]) ps[1].innerHTML = `🎖️ 目前仙門位階：${gameState.current_title}`;
    let tip = "🌟 你已達到最終修為！";
    let progressVal = 100;
    if (nextInfo) {
        tip = `⬆️ 距離「${nextInfo.next_stage}」還差 ${nextInfo.exp_needed} 修煉經驗、訓練 ${nextInfo.train_needed} 次`;
        let prevNeed = 0;
        for (const [need_exp] of CULTIVATION_STAGES) {
            if (gameState.exp >= need_exp) prevNeed = need_exp;
            else break;
        }
        let nextNeed = CULTIVATION_STAGES.find(([need_exp]) => gameState.exp < need_exp)?.[0];
        if (nextNeed !== undefined) {
            const span = Math.max(1, nextNeed - prevNeed);
            progressVal = Math.floor((gameState.exp - prevNeed) * 100 / span);
        }
    }
    if (ps[2]) ps[2].innerHTML = tip;
    const progressEl = info.querySelector('progress');
    if (progressEl) progressEl.value = progressVal;
    if (ps[3]) ps[3].innerHTML = `🏋️ 累積訓練次數：${gameState.total} | ⚔️ 修煉經驗：${gameState.exp} | ⭐ 最高分：${highestScore}`;
    if (ps[4]) ps[4].innerHTML = `🎟️ 測試機會：${gameState.luck_tickets} 次 (累積獲得：${gameState.luck_tickets_total})`;
    if (ps[5]) ps[5].innerHTML = `💎 靈石：${gameState.stones}`;
}

function showBackpack() {
    const sortedInventory = Object.entries(gameState.inventory)
      .filter(([, qty]) => qty > 0)
      // 使用 compareItemNames 確保依類型與品階排序
      .sort(([a], [b]) => compareItemNames(a, b));
    let content = '';
    if (sortedInventory.length === 0) {
      content = "<p>背包空空如也</p>";
    } else {
      content = '<ul style="padding-left: 20px;">' +
        sortedInventory.map(([name, qty]) => `<li>${name} ×${qty}</li>`).join('') +
        '</ul>';
    }
    const footer = `
      <button data-action="use-exp-items">🍵 使用仙丹</button>
      <button class="btn-danger" data-action="delete-items">🗑️ 刪除道具</button>`;
    showModal("🎒 背包", content, footer);
}

// === 使用仙丹（EXP 類）===
function showUseExpDialog() {
  const expItems = Object.entries(gameState.inventory)
    .filter(([name, qty]) => qty > 0 && (ITEM_EFFECTS[name]?.type === 'exp'))
    // 依類型與品階排序
    .sort(([a], [b]) => compareItemNames(a, b));
  let content = '';
  if (expItems.length === 0) {
    content = "<p>沒有可用的仙丹類道具</p>";
  } else {
    content = expItems.map(([name, qty]) => {
      const eff = ITEM_EFFECTS[name] || {};
      const addExp = eff.n || 0;
      return `
        <div class="modal-item-row">
          <label for="useexp-${name}">${name}（持有 ${qty}）→ 每顆 +${addExp} EXP</label>
          <input type="number" id="useexp-${name}" min="0" max="${qty}" value="0" />
        </div>`;
    }).join('');
  }
  const footer = `
    <button data-action="fill-all-exp">全部填滿</button>
    <button data-action="confirm-use-exp">確認使用</button>
    <button data-action="confirm-use-exp-all" class="btn-warning">全部使用</button>`;
  showModal("🍵 使用仙丹", content, footer);
}

function confirmUseExp() {
  const inputs = modalBody.querySelectorAll('input[type="number"]');
  let totalGain = 0;
  const inv = gameState.inventory;
  inputs.forEach(input => {
    const qty = Math.max(0, parseInt(input.value || '0', 10));
    if (!qty) return;
    const name = input.id.replace('useexp-', '');
    const eff = ITEM_EFFECTS[name] || {};
    const add = (eff.n || 0) * qty;
    const cur = inv[name] || 0;
    inv[name] = Math.max(0, cur - qty);
    totalGain += add;
  });
  if (totalGain > 0) {
    const prevExp = gameState.exp;
    gameState.exp += totalGain;
    saveGameState();
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    showModal("🍵 使用結果",
      `<p>共獲得 +${totalGain} EXP</p>${levelupMsg ? `<p class="msg-levelup">${levelupMsg}</p>` : ''}`,
      `<button data-action="close-modal">關閉</button>`);
  } else {
    showModal("🍵 使用結果", "<p>未選擇任何仙丹。</p>", `<button data-action="close-modal">關閉</button>`);
  }
}

// === 批量填滿與全部使用 EXP 類仙丹 ===
function fillAllExpInputs() {
  const inputs = modalBody.querySelectorAll('input[id^="useexp-"]');
  inputs.forEach(input => {
    const max = parseInt(input.getAttribute('max') || '0', 10);
    if (max > 0) input.value = String(max);
  });
}

function confirmUseExpAll() {
  const inv = gameState.inventory;
  let totalGain = 0;
  Object.entries(inv).forEach(([name, qty]) => {
    if (qty > 0 && (ITEM_EFFECTS[name]?.type === 'exp')) {
      const eff = ITEM_EFFECTS[name];
      const add = (eff.n || 0) * qty;
      inv[name] = 0;
      totalGain += add;
    }
  });
  if (totalGain > 0) {
    const prevExp = gameState.exp;
    gameState.exp += totalGain;
    saveGameState();
    const levelupMsg = handleLevelUp(prevExp, gameState.exp);
    showModal("🍵 使用結果",
      `<p>共獲得 +${totalGain} EXP（全部使用）</p>${levelupMsg ? `<p class="msg-levelup">${levelupMsg}</p>` : ''}`,
      `<button data-action="close-modal">關閉</button>`);
  } else {
    showModal("🍵 使用結果", "<p>沒有可用的仙丹。</p>", `<button data-action="close-modal">關閉</button>`);
  }
}

// === 刪除道具 ===
function showDeleteItemsDialog() {
  const deletables = Object.entries(gameState.inventory)
    .filter(([, qty]) => qty > 0)
    // 依類型與品階排序
    .sort(([a], [b]) => compareItemNames(a, b));
  let content = '';
  if (deletables.length === 0) {
    content = "<p>背包沒有可以刪除的道具</p>";
  } else {
    content = deletables.map(([name, qty]) => `
      <div class="modal-item-row">
        <label for="del-${name}">${name}（持有 ${qty}）</label>
        <input type="number" id="del-${name}" min="0" max="${qty}" value="0" />
      </div>`).join('');
  }
  const footer = `<button data-action="confirm-delete-items">確認刪除</button>`;
  showModal("🗑️ 刪除道具", content, footer);
}

function confirmDeleteItems() {
  const inputs = modalBody.querySelectorAll('input[type="number"]');
  const inv = gameState.inventory;
  let removedList = [];
  inputs.forEach(input => {
    const qty = Math.max(0, parseInt(input.value || '0', 10));
    if (!qty) return;
    const name = input.id.replace('del-', '');
    const cur = inv[name] || 0;
    const rm = Math.min(qty, cur);
    if (rm > 0) {
      inv[name] = cur - rm;
      removedList.push(`${name} ×${rm}`);
    }
  });
  saveGameState();
  showModal("🗑️ 刪除結果",
    removedList.length ? `<p>已刪除：${removedList.join('、')}</p>` : "<p>未刪除任何道具</p>",
    `<button data-action="close-modal">關閉</button>`);
}

function showShop() {
    const sortedItems = Object.entries(ITEM_STONE_PRICES).sort(([a], [b]) => {
        const keyA = getItemSortKey(a);
        const keyB = getItemSortKey(b);
        if (keyA[0] !== keyB[0]) return keyA[0] - keyB[0];
        if (keyA[1] !== keyB[1]) return keyA[1] - keyB[1];
        return a.localeCompare(b, 'zh-Hant');
    });

    let content = `<p style="text-align:center;"><b>當前靈石：${gameState.stones}</b></p>`;
    content += sortedItems.map(([item, cost]) => {
        const desc = ITEM_EFFECTS[item]?.desc || '';
        return `<div class="modal-item-row">
            <label for="shop-${item}">${item} - ${cost} 靈石 (${desc})</label>
            <input type="number" id="shop-${item}" min="0" value="0" placeholder="0">
        </div>`;
    }).join('');

    let footer = `<button data-action="bulk-buy-items">購買選擇</button>
                  <button class="btn-warning" data-action="show-sell-dialog">販賣道具</button>
                  <button class="btn-secondary" data-action="show-upgrade-dialog">品階升級</button>`;
    
    showModal("🛒 商店", content, footer);
}

function bulkBuyItems() {
    const inputs = modalBody.querySelectorAll('input[type="number"]');
    let totalCost = 0;
    const purchase = {};

    inputs.forEach(input => {
        const qty = parseInt(input.value, 10);
        if (qty > 0) {
            const itemName = input.id.replace('shop-', '');
            const price = ITEM_STONE_PRICES[itemName] || 0;
            totalCost += price * qty;
            purchase[itemName] = qty;
        }
    });

    if (totalCost > gameState.stones) {
        alert(`靈石不足！需要 ${totalCost}，您只有 ${gameState.stones}。`);
        return;
    }

    if (Object.keys(purchase).length > 0) {
        gameState.stones -= totalCost;
        Object.entries(purchase).forEach(([item, qty]) => {
            gameState.inventory[item] = (gameState.inventory[item] || 0) + qty;
            if (!gameState.inventory_order.includes(item)) {
                gameState.inventory_order.push(item);
                 gameState.inventory_order.sort((a, b) => compareItemNames(a, b));
            }
        });
        saveGameState();
        addTemporaryMessage(`✅ 購買成功，花費 ${totalCost} 靈石！`, 'msg-shop');
    }
    modal.style.display = "none";
    renderMainMenu();
}

function showUpgradeDialog() {
    const upgradable = Object.keys(UPGRADE_PATHS)
        .filter(item => (gameState.inventory[item] || 0) > 0 && !(gameState.inventory[UPGRADE_PATHS[item]] > 0))
        // 依類型與品階排序
        .sort((a,b) => compareItemNames(a, b));

    let content = `<p style="text-align:center;"><b>當前靈石：${gameState.stones}</b></p>`;
    if (upgradable.length === 0) {
        content += `<p>沒有可升級的道具。</p>`;
    } else {
        content += upgradable.map(item => {
            const nextItem = UPGRADE_PATHS[item];
            const cost = ITEM_EFFECTS[item].upgrade_cost || 0;
            return `<div class="modal-item-row">
                <span>升級 ${item} → ${nextItem}</span>
                <button data-action="upgrade-item" data-current="${item}" data-next="${nextItem}" data-cost="${cost}" ${gameState.stones < cost ? 'disabled' : ''}>${cost} 靈石</button>
            </div>`;
        }).join('');
    }
    showModal("✨ 品階升級", content, `<button data-action="show-shop">返回商店</button>`);
}

function upgradeItem(currentItem, nextItem, cost) {
    if (gameState.stones < cost) {
        alert("靈石不足！");
        return;
    }
    gameState.stones -= cost;
    gameState.inventory[nextItem] = (gameState.inventory[nextItem] || 0) + 1;
    // Don't remove old item
    if (!gameState.inventory_order.includes(nextItem)) {
        gameState.inventory_order.push(nextItem);
        gameState.inventory_order.sort((a,b) => compareItemNames(a,b));
    }
    saveGameState();
    // 扣靈石後立即更新主畫面資訊（尤其是靈石顯示）
    if (typeof updateMainMenuInfo === 'function') {
        updateMainMenuInfo();
    }
    alert(`升級成功！獲得 ${nextItem}`);
    showUpgradeDialog(); // Refresh modal
}

// ===================== 遊戲中道具使用 =====================

function showUseItemDialog() {
    const usableItems = Object.entries(gameState.inventory)
      .filter(([, qty]) => qty > 0)
      .map(([name]) => name)
      .filter(name => {
        const type = ITEM_EFFECTS[name]?.type;
        return ["correct", "wrong", "multi_choice", "reveal_wrong", "add_time"].includes(type);
      })
      // 依類型與品階排序
      .sort((a, b) => compareItemNames(a, b));
    let content = '';
    if (usableItems.length === 0) {
      content = '<p>沒有可用的戰鬥道具</p>';
    } else {
      content = usableItems.map(item => {
        const eff = ITEM_EFFECTS[item];
        const cost = eff.exp_cost || 0;
        let disabled = '';
        let tooltip = '';
        if (gameState.exp < cost) {
          disabled = 'disabled';
          tooltip = ` (修煉經驗不足: ${cost})`;
        }
        if (['correct', 'wrong', 'multi_choice'].includes(eff.type) && trainingState.hasUsedSingleUseItem) {
          disabled = 'disabled';
          tooltip = ' (本題已用過此類道具)';
        }
        if (['correct', 'wrong'].includes(eff.type)) {
          const allowedGrade = getGradeByDifficulty(trainingState.difficulty);
          if (!item.startsWith(allowedGrade)) {
            disabled = 'disabled';
            tooltip = ` (此難度需用 ${allowedGrade} 道具)`;
          }
        }
        return `<button data-action="use-item" data-item-name="${item}" ${disabled}>
          ${item} ×${gameState.inventory[item]}
          <br><small>${eff.desc || ''}${cost > 0 ? ` (消耗${cost} EXP)` : ''}${tooltip}</small>
        </button>`;
      }).join('');
    }
    showModal('🎒 使用道具', content);
}

function useItem(itemName) {
    const eff  = ITEM_EFFECTS[itemName];
    if (!eff) return;
    const cost = eff.exp_cost || 0;
    if (gameState.exp < cost) return;
    if (['correct', 'wrong', 'multi_choice'].includes(eff.type)) {
      if (trainingState.hasUsedSingleUseItem) return;
      trainingState.hasUsedSingleUseItem = true;
    }
    gameState.exp -= cost;
    if (['correct', 'wrong'].includes(eff.type)) {
      gameState.inventory[itemName] = Math.max(0, (gameState.inventory[itemName] || 0) - 1);
    }
    saveGameState();
    const fb = document.getElementById('feedback-label');
    let msg = '';
    if (eff.type === 'multi_choice') {
      trainingState.allowedChoices += (eff.n || 1);
      enterMultiChoiceMode();
      msg = `⚔️ 兵器效果：本題可選答案數增加 ${eff.n}（總共 ${trainingState.allowedChoices} 次）`;
    } else if (eff.type === 'reveal_wrong') {
      const buttons = trainingState.gameGridButtons || [];
      let remain = eff.n || 1;
      for (const b of buttons) {
        if (remain <= 0) break;
        const choice = b.dataset.choice;
        if (!trainingState.correctAnswers.includes(choice) && !b.classList.contains('hint-wrong')) {
          b.classList.add('hint-wrong');
          remain--;
        }
      }
      msg = `📜 功法效果：已標示 ${eff.n} 個錯誤答案`;
    } else if (eff.type === 'add_time') {
      // 陣法增加作答時間僅限本題有效：中途可以疊加並即時生效
      const inc = eff.n || 0;
      trainingState.roundExtraTime = (trainingState.roundExtraTime || 0) + inc;
      // 若倒數正在跑，立即增加剩餘秒數
      if (typeof trainingState.countdownRemaining === 'number') {
        trainingState.countdownRemaining += inc;
        const label = document.getElementById('countdown-label');
        if (label && trainingState.countdownRemaining >= 0) {
          label.textContent = `作答倒數：${trainingState.countdownRemaining} 秒`;
        }
      }
      msg = `⛩️ 陣法效果：作答時間增加 ${inc} 秒（僅本題）`;
    } else if (eff.type === 'correct') {
// 靈器：顯示正確答案。n <= 0 視為全部，否則顯示 n 個
const buttons = trainingState.gameGridButtons || [];
// 找出所有尚未標示的正確按鈕
const correctButtons = buttons.filter(b =>
  trainingState.correctAnswers.includes(b.dataset.choice) && !b.classList.contains('hint-correct')
);
let toReveal;
if (eff.n <= 0) {
  // n <= 0 表示全部亮顯
  toReveal = correctButtons;
} else {
  // 否則只顯示前 n 個
  toReveal = correctButtons.slice(0, eff.n);
}
// 將選中的按鈕標記為正確
toReveal.forEach(b => b.classList.add('hint-correct'));
msg = `🪬 靈器效果：已標示 ${eff.n <= 0 ? '全部' : toReveal.length} 個正確答案`;
    } else if (eff.type === 'wrong') {
      const buttons = trainingState.gameGridButtons || [];
      let remain = eff.n || 1;
      for (const b of buttons) {
        if (remain <= 0) break;
        const choice = b.dataset.choice;
        if (!trainingState.correctAnswers.includes(choice) && !b.classList.contains('hint-wrong')) {
          b.classList.add('hint-wrong');
          remain--;
        }
      }
      msg = `🧿 靈符效果：已排除 ${eff.n} 個錯誤答案`;
    }
    if (fb) { fb.textContent = msg; fb.className = "feedback info"; }
    modal.style.display = 'none';
}

// Stubs for unimplemented modal functions
function useExpItems() { showUseExpDialog(); }
function deleteItems() { showDeleteItemsDialog(); }
function showSellDialog() {
  const sellable = Object.entries(gameState.inventory)
    .filter(([name, qty]) => qty > 0 && ITEM_STONE_PRICES[name] !== undefined)
    // 依類型與品階排序
    .sort(([a], [b]) => compareItemNames(a, b));
  let content = '';
  if (sellable.length === 0) {
    content = '<p>背包中沒有可販賣的道具。</p>';
  } else {
    content = sellable.map(([name, qty]) => {
      const sellPriceSingle = Math.floor((ITEM_STONE_PRICES[name] || 0) / 2);
      return `
        <div class="modal-item-row">
          <label for="sell-${name}">${name}（持有 ${qty}） - 賣價: ${sellPriceSingle} 靈石/個</label>
          <input type="number" id="sell-${name}" min="0" max="${qty}" value="0" />
        </div>`;
    }).join('');
    content += `<p id="sell-total" style="margin-top:10px;text-align:center;">預計可獲得：0 靈石</p>`;
  }
  const footer = `<button data-action="confirm-sell-items">確認販賣</button>`;
  showModal("💰 販賣道具", content, footer);
  // attach update for predicted sell value
  setTimeout(() => {
    const totalLabel = document.getElementById('sell-total');
    function updateTotal() {
      let totalBuyValue = 0;
      sellable.forEach(([name]) => {
        const input = modalBody.querySelector(`#sell-${name}`);
        if (input) {
          const count = parseInt(input.value || '0', 10);
          if (count > 0) {
            const price = ITEM_STONE_PRICES[name] || 0;
            totalBuyValue += price * count;
          }
        }
      });
      const sellValue = Math.floor(totalBuyValue / 2);
      if (totalLabel) {
        totalLabel.textContent = `預計可獲得：${sellValue} 靈石`;
      }
    }
    sellable.forEach(([name]) => {
      const input = modalBody.querySelector(`#sell-${name}`);
      if (input) {
        input.addEventListener('input', updateTotal);
        input.addEventListener('change', updateTotal);
      }
    });
    updateTotal();
  }, 0);
}

function confirmSellItems() {
  const toSell = [];
  let totalBuyValue = 0;
  Object.entries(gameState.inventory).forEach(([name, qty]) => {
    const input = modalBody.querySelector(`#sell-${name}`);
    if (input) {
      const count = Math.max(0, parseInt(input.value || '0', 10));
      if (count > 0) {
        toSell.push({name: name, qty: count});
        totalBuyValue += (ITEM_STONE_PRICES[name] || 0) * count;
      }
    }
  });
  if (toSell.length === 0) {
    showModal("💰 販賣結果", "<p>未販賣任何道具</p>", `<button data-action="close-modal">關閉</button>`);
    return;
  }
  const sellValue = Math.floor(totalBuyValue / 2);
  toSell.forEach(item => {
    gameState.inventory[item.name] = Math.max(0, (gameState.inventory[item.name] || 0) - item.qty);
  });
  gameState.stones += sellValue;
  saveGameState();
  const soldItemsDesc = toSell.map(item => `${item.name} ×${item.qty}`);
  showModal("💰 販賣結果", `<p>已販賣：${soldItemsDesc.join('、')}</p><p>獲得 ${sellValue} 靈石</p>`, `<button data-action="close-modal">關閉</button>`);
}


// ===================== 全域事件處理 =====================
document.body.addEventListener('click', (event) => {
    let target = event.target;
    // If the target itself doesn't have the action, check its parent
    if (!target.dataset.action) {
        target = target.closest('[data-action]');
    }
    if (!target) return;

    const action = target.dataset.action;
    
    const simpleActions = {
        'render-main-menu': renderMainMenu, 'render-test-luck-menu': renderTestLuckMenu,
        'show-stage-list': showStageList, 'show-rank-list': showRankList,
        'show-backpack': showBackpack, 'show-shop': showShop,
        'reset-stats': resetTrainingStats, 'clear-scores': clearMaxScores,
        'run-today-luck': runTodayLuck, 'show-luck-history': showLuckHistory,
        'show-upgrade-dialog': showUpgradeDialog, 'check-answer-multi': checkAnswerMulti,
        'show-use-item-dialog': showUseItemDialog, 'close-modal': () => modal.style.display = "none",
        'bulk-buy-items': bulkBuyItems,
        'use-exp-items': showUseExpDialog,
        'delete-items': showDeleteItemsDialog,
        'confirm-use-exp': confirmUseExp,
        'confirm-delete-items': confirmDeleteItems,
        'fill-all-exp': fillAllExpInputs,
        'confirm-use-exp-all': confirmUseExpAll,
        'confirm-sell-items': confirmSellItems,
        'show-sell-dialog': showSellDialog,
        'show-game-rules': showGameRules,
        'test-sfx': () => {
            try {
                if (typeof ensureAudio === 'function' && typeof playBeep === 'function') {
                    ensureAudio();
                    playBeep({ freq: 880 });
                }
            } catch (e) {}
        },
    };

    if (simpleActions[action]) {
        simpleActions[action]();
        return;
    }

    // Actions with parameters
    switch(action) {
        case 'start-training':
            startTraining(parseInt(target.dataset.level, 10));
            break;
        case 'exchange-stones':
            exchangeStones(parseInt(target.dataset.count, 10));
            break;
        case 'redeem-tickets':
            redeemTickets(parseInt(target.dataset.pieces, 10), parseInt(target.dataset.cost, 10));
            break;
        case 'run-luck-draw':
            runLuckDraw(parseInt(target.dataset.draws, 10), target.dataset.mode);
            break;
        case 'upgrade-item':
            upgradeItem(target.dataset.current, target.dataset.next, parseInt(target.dataset.cost, 10));
            break;
        case 'use-item':
            useItem(target.dataset.itemName);
            break;
        case 'grid-btn': 
            onGridButtonClick(target);
            break;
    }
});


// ===================== 啟動遊戲 =====================
loadGameState();
renderMainMenu();

}); // ▲▲▲ End of DOMContentLoaded listener ▲▲▲
</script>

<!-- 音效與箭頭後援程式：在行動裝置上顯示箭頭，並生成音效（無需外部音檔） -->
<script>
// ==== 行動裝置箭頭 SVG 後援 ====
function svgArrow(dir, size = 18) {
    const pathMap = {
        up:   'M9 2 L16 14 H2 Z',
        right:'M2 2 L14 9 L2 16 Z',
        down: 'M2 2 L16 2 L9 16 Z',
        left: 'M2 9 L14 2 L14 16 Z'
    };
    const key = pathMap[dir] ? dir : 'up';
    const svg = `<svg viewBox="0 0 18 18" width="${size}" height="${size}" aria-hidden="true" style="display:inline-block;vertical-align:middle"><path d="${pathMap[key]}" fill="currentColor"/></svg>`;
    const el = document.createElement('span');
    el.className = 'luck-arrow-svg';
    el.innerHTML = svg;
    return el;
}

// 將含有箭頭字元或指定 data 屬性的節點替換為 SVG
function patchLuckArrows() {
    const selector = '.luck-arrow, [data-luck-arrow], [data-dir]';
    document.querySelectorAll(selector).forEach(node => {
        // 已經有 SVG 就不重複替換
        if (node.querySelector('svg')) return;
        // 判斷方向
        let dir = node.dataset.luckArrow || node.dataset.dir || '';
        // 若未指定，根據內容判斷
        if (!dir) {
            const text = node.textContent.trim();
            const map = {'↑': 'up', '→': 'right', '↓': 'down', '←': 'left'};
            dir = map[text] || 'up';
        }
        // 清空文字並插入 SVG
        node.textContent = '';
        node.appendChild(svgArrow(dir));
    });
}

// ==== WebAudio 音效工具 ====
let __audioCtx = null;
function ensureAudio() {
    if (!__audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        __audioCtx = new Ctx();
    }
    return __audioCtx;
}

function playBeep(opts) {
    const cfg = Object.assign({ freq: 880, dur: 0.12, type: 'sine', gain: 0.06 }, opts);
    const ctx = ensureAudio();
    if (!ctx) return;
    const osc = ctx.createOscillator();
    const gainNode = ctx.createGain();
    osc.type = cfg.type;
    osc.frequency.value = cfg.freq;
    gainNode.gain.value = cfg.gain;
    osc.connect(gainNode).connect(ctx.destination);
    const t = ctx.currentTime;
    osc.start(t);
    osc.stop(t + cfg.dur);
}

function playLevelUp() {
    const ctx = ensureAudio();
    if (!ctx) return;
    const now = ctx.currentTime;
    // 上行小和弦：C-E-G 依序響起
    [[523.25, 0], [659.25, 0.08], [783.99, 0.16]].forEach(([freq, offset]) => {
        const osc = ctx.createOscillator();
        const gainNode = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        gainNode.gain.value = 0.05;
        osc.connect(gainNode).connect(ctx.destination);
        osc.start(now + offset);
        osc.stop(now + offset + 0.18);
    });
}

// ==== 初始化與事件綁定 ====
window.addEventListener('DOMContentLoaded', () => {
    try {
        patchLuckArrows();
    } catch (e) {}
});
</script>

</body>
</html>
